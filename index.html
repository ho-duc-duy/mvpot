<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MV Suggestion Tool</title>
    <style>
        /* Basic Reset & Defaults */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa; /* Lighter background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        main {
            flex-grow: 1; /* Pushes footer elements down */
            padding-top: 80px; /* Increased padding for taller nav */
            width: 100%;
        }

        /* Navigation */
        .main-nav {
            background-color: rgba(51, 51, 51, 0.9); /* Slightly transparent dark */
            backdrop-filter: blur(5px); /* Blur effect for nav background */
            color: #fff;
            position: fixed; /* Keeps nav on top */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between; /* Space between logo and menu */
            align-items: center;
            padding: 10px 25px; /* Padding around nav */
            height: 70px; /* Fixed height */
        }

        .logo-placeholder {
            max-width: 120px;
            max-height: 50px;
            object-fit: contain;
            user-select: none;
            /* Basic styling if image fails to load */
            color: white;
            text-align: center;
            line-height: 50px; /* Center text vertically */
            font-size: 0.8em;
            font-weight: bold;
            overflow: hidden;
        }


        .main-nav ul {
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }

        .main-nav ul li {
            margin-left: 30px;
        }

        .main-nav ul li a {
            color: #fff;
            text-decoration: none;
            padding: 8px 12px;
            font-size: 1.05em;
            border-radius: 4px;
            transition: color 0.3s ease, background-color 0.3s ease, border-bottom 0.3s ease;
            border-bottom: 3px solid transparent;
            cursor: pointer;
        }

        .main-nav ul li a:hover,
        .main-nav ul li a.active {
            color: #e0cff0;
            border-bottom: 3px solid #9E69AF;
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* Page Sections */
        .page {
            display: none;
            padding: 30px 20px;
            animation: fadeIn 0.6s ease-in-out;
            min-height: calc(100vh - 110px); /* Adjust based on footer height if added */
            position: relative;
            padding-bottom: 80px; /* Space for back button */
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .content-container {
            max-width: 950px;
            margin: 20px auto;
            background-color: #fff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        /* Headings */
        h1, h2 {
            color: #343a40;
            margin-bottom: 20px;
            font-weight: 600;
        }
         h3 { /* Added for budget columns */
             color: #495057;
             margin-bottom: 10px;
             font-size: 1.15em;
             font-weight: 600;
         }

        h1 {
            text-align: center;
            font-size: 2.4em;
            color: #495057;
        }

        h2 {
            font-size: 1.9em;
            border-bottom: 2px solid #eee;
            padding-bottom: 8px;
            margin-top: 35px;
            color: #6E91D6;
        }
        .result-section h2 {
             color: #9E69AF;
             border-color: #e0d1e6;
        }


        /* Button General Styling & Gradient */
        .btn {
            display: inline-block;
            padding: 14px 28px;
            margin: 10px 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.05em;
            font-weight: 600;
            text-align: center;
            text-decoration: none;
            color: #fff;
            background: linear-gradient(135deg, #9E69AF, #6E91D6);
            background-size: 200% 200%;
            transition: background-position 0.4s ease-out, transform 0.15s ease, box-shadow 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        /* Button Hover Animation */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .btn:hover {
            animation: gradientShift 4s ease infinite;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(138, 105, 175, 0.4);
        }

        .btn:active {
            transform: scale(0.97) translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Specific Button Styles */
         .btn-primary { /* Explore Now & Get Suggestions */ }
         .btn-secondary { /* Go Back */
             background: linear-gradient(135deg, #6c757d, #495057);
             background-size: 200% 200%;
         }
          .btn-secondary:hover { box-shadow: 0 4px 10px rgba(80, 80, 80, 0.3); }
         .btn-warning { /* Record */
             background: linear-gradient(135deg, #ffc107, #ff9800);
             background-size: 200% 200%;
             color: #333;
         }
         .btn-warning:hover { box-shadow: 0 4px 10px rgba(255, 170, 0, 0.4); color: #111; }
         .btn-danger { /* Stop Recording */
             background: linear-gradient(135deg, #dc3545, #c82333);
             background-size: 200% 200%;
         }
         .btn-danger:hover { box-shadow: 0 4px 10px rgba(220, 50, 70, 0.4); }


        .btn-back {
            position: absolute;
            bottom: 20px;
            left: 25px;
            margin: 0;
            z-index: 10;
        }
        #home-page .btn-back { display: none; }


        /* Home Page Specific & Parallax Setup */
        .hero-container {
            position: relative;
            width: 100%;
            height: 65vh; /* Adjust as needed */
            min-height: 450px;
            max-height: 700px;
            overflow: hidden; /* Crucial for parallax */
            border-radius: 10px;
            margin: 0 auto 30px auto;
             /* Basic styling if image fails to load */
            background-color: #ddd;
        }

        .hero-image {
            position: absolute; /* Needed for transform control */
            left: 0;
            top: 0; /* Adjust if using scale */
            width: 100%;
            height: 100%; /* Start at 100%, scale can make it bigger */
            object-fit: cover;
            display: block;
            filter: blur(4px) brightness(0.9);
            /* Scale slightly larger to prevent edges showing during parallax movement */
            transform: scale(1.1);
            /* transform will be updated by JS */
            will-change: transform; /* Hint for browser optimization */
        }

        .hero-text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 40px 50px;
            border-radius: 8px;
            text-align: center;
            max-width: 85%;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 1; /* Ensure text is above image */
        }

        .hero-text-overlay h1 {
            font-size: 2.8em;
            margin-bottom: 25px;
            color: #fff;
            border: none;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        /* About Page Specific */
        #about-page p {
            max-width: 750px;
            margin: 30px auto;
            text-align: justify;
            font-size: 1.1em;
            color: #495057;
        }

        /* Feature Page Specific */
        #feature-form { margin-top: 30px; }
        .form-group { margin-bottom: 30px; }
        .form-group label { display: block; margin-bottom: 10px; font-weight: 600; color: #495057; font-size: 1.05em; }
        .form-group input[type="text"], .form-group textarea, .form-group select, .form-group input[type="file"] {
            width: 100%; padding: 14px; border: 1px solid #ced4da; border-radius: 6px; font-size: 1em; margin-bottom: 5px; transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
             border-color: #8a6fb5; box-shadow: 0 0 0 3px rgba(158, 105, 175, 0.2); outline: none;
        }
        .form-group textarea { resize: vertical; min-height: 120px; }
         .form-group select {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%236c757d" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat; background-position: right 12px center; background-size: 20px; padding-right: 45px; cursor: pointer;
         }
         .form-group select option[disabled] { color: #999; }

        /* Audio Input Group Styling */
        .audio-input-group { display: flex; align-items: center; flex-wrap: wrap; gap: 10px; }
        .form-group input[type="file"] { padding: 8px 12px; cursor: pointer; flex-grow: 1; min-width: 200px; margin-bottom: 0; }
        input[type="file"]::file-selector-button { padding: 10px 18px; margin-right: 12px; border: none; border-radius: 5px; background: linear-gradient(135deg, #6c757d, #495057); color: #fff; cursor: pointer; transition: background 0.3s ease, transform 0.1s ease; font-weight: 600; }
        input[type="file"]::file-selector-button:hover { transform: scale(1.03); }
         input[type="file"]::file-selector-button:active { transform: scale(0.98); }
        .optional-notice { margin-left: 5px; font-size: 0.9em; color: #6c757d; font-style: italic; vertical-align: middle; }

        #record-status { margin-left: 15px; font-style: italic; font-weight: 500; display: inline-flex; align-items: center; min-height: 24px; }
        #record-status.recording { color: #dc3545; }
        #record-status.transcribing { color: #007bff; }
        #record-status.complete { color: #28a745; }
        #record-status.error { color: #dc3545; }

        /* Recording Animation Styles */
        .recording-dots { display: inline-block; vertical-align: middle; margin-right: 6px; }
        .recording-dots span { display: inline-block; width: 8px; height: 8px; margin-left: 3px; border-radius: 50%; background-color: #dc3545; animation: blink 1.4s infinite both; }
        .recording-dots span:nth-child(1) { animation-delay: 0s; }
        .recording-dots span:nth-child(2) { animation-delay: 0.2s; }
        .recording-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink { 0%, 80%, 100% { opacity: 0; } 40% { opacity: 1; } }

         /* Transcript output area */
        #transcript-group { display: none; margin-top: 20px; }
        #transcript-output { background-color: #e9ecef; font-style: italic; color: #495057; min-height: 80px; cursor: default; }
        .form-group small { display: block; margin-top: 8px; color: #6c757d; font-size: 0.9em; }
        #get-suggestions-button { display: block; width: 100%; max-width: 350px; margin: 40px auto 0 auto; padding: 16px 30px; font-size: 1.15em; }

        /* Results Area */
        #results-area { margin-top: 50px; padding-top: 30px; border-top: 2px solid #eee; display: none; }
        .result-section { background-color: #ffffff; padding: 25px 30px; margin-bottom: 25px; border-radius: 8px; border: 1px solid #e9ecef; box-shadow: 0 2px 8px rgba(0,0,0,0.05); display: none; }

        /* General content styling (will be overridden for specific sections like lists/images) */
        .result-section .content { font-size: 1em; color: #495057; line-height: 1.7; }
        #result-concept .content p { white-space: pre-wrap; } /* Allow wrapping for concept */

        /* List styling (for Requirements) */
        #result-requirements .content ul { margin-left: 0; margin-top: 10px; margin-bottom: 10px; padding-left: 0; list-style: none; }
         #result-requirements li { margin-bottom: 10px; padding-left: 25px; position: relative; }
         #result-requirements li::before { content: 'â–¹'; color: #6E91D6; font-size: 1.2em; position: absolute; left: 0; top: -2px; }

        /* --- Budget Column Styles --- */
        .budget-columns-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Create 3 equal columns */
            gap: 25px; /* Space between columns */
            margin-top: 15px;
        }
        .budget-column {
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 6px;
            background-color: #fdfdff; /* Slightly off-white */
        }
        .budget-column h3 {
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            color: #6E91D6; /* Match section header color */
            font-size: 1.2em;
        }
        .budget-column p {
            font-size: 0.95em;
            line-height: 1.6;
            color: #495057;
            white-space: pre-wrap; /* Allow wrapping for budget description & potential line breaks */
        }
        .budget-column p strong { /* Style potential bolded costs */
            font-weight: 600;
            color: #333;
        }

        /* Image Placeholder Styles */
        .image-placeholder-container { display: grid; gap: 20px; margin-top: 15px; }
        /* Grid definitions remain the same */
        #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
        #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }

        .image-placeholder { border: 1px solid #dee2e6; border-radius: 6px; background-color: #f8f9fa; overflow: hidden; text-align: center; color: #495057; box-shadow: 0 1px 4px rgba(0,0,0,0.05); transition: transform 0.3s ease, box-shadow 0.3s ease; position: relative; }
        .image-placeholder:hover { transform: translateY(-3px); box-shadow: 0 4px 10px rgba(0,0,0,0.08); }
        .image-placeholder img { display: block; width: 100%; object-fit: cover; background-color: #e9ecef; border-bottom: 1px solid #dee2e6; }
        /* Adjusted heights based on container */
        #result-visuals .image-placeholder img { height: 180px; }
        #result-moodboard .image-placeholder img { height: 140px; }

        .image-placeholder figcaption { font-size: 0.9em; padding: 10px 12px 15px 12px; background-color: #fff; min-height: 50px; line-height: 1.4; }
        /* Style attribution link */
        .image-placeholder figcaption a { font-size: 0.75em; display: block; margin-top: 5px; color: #6c757d; text-decoration: none; transition: color 0.2s ease; }
        .image-placeholder figcaption a:hover { color: #495057; }
        .image-placeholder figcaption .fallback-notice { font-size: 0.75em; display: block; margin-top: 3px; color: #888; font-style: italic; }

        /* Specific Small Notes */
        .result-section small { display: block; margin-top: 15px; color: #6c757d; font-style: italic; font-size: 0.85em; }

        /* Color Palette Display */
        .color-palette-display { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 15px; }
        .color-swatch { min-width: 110px; height: 80px; border-radius: 6px; border: 1px solid rgba(0, 0, 0, 0.1); display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.9em; font-weight: 600; text-align: center; overflow: hidden; padding: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: transform 0.2s ease; flex-grow: 1; }
        .color-swatch:hover { transform: scale(1.05); }
        .color-swatch span { display: block; word-break: break-word; max-width: 100%; }
        .color-swatch .hex-code { margin-top: 8px; font-size: 1em; font-family: 'Courier New', Courier, monospace; user-select: all; opacity: 0.85; }

        /* Loading Spinner */
        #loading-indicator { text-align: center; margin-top: 30px; }
        #loading-indicator p { font-weight: 500; color: #495057; margin-bottom: 15px;}
        .spinner { border: 5px solid rgba(0, 0, 0, 0.1); width: 40px; height: 40px; border-radius: 50%; border-left-color: #6E91D6; margin: 0 auto; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Error Message */
        .error-message { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; padding: 18px 25px; border-radius: 6px; margin: 25px 0; text-align: center; font-weight: 500; display: none; }

        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
             .content-container { max-width: 90%; padding: 30px; }
             h1 { font-size: 2.1em; } h2 { font-size: 1.7em; }
             .hero-text-overlay h1 { font-size: 2.4em; }
             #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
             #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); }
             #result-visuals .image-placeholder img { height: 160px; }
             #result-moodboard .image-placeholder img { height: 130px; }
             /* Budget columns stack on medium screens */
             .budget-columns-container { grid-template-columns: 1fr; }
        }

        @media (max-width: 768px) {
            .main-nav { padding: 10px 15px; height: auto; flex-direction: column; align-items: flex-start; }
            .logo-placeholder { margin-bottom: 10px; width: 100px; /* Adjusted */ height: auto; }
            .main-nav ul { justify-content: flex-start; width: 100%; padding-top: 10px; flex-wrap: wrap; }
             .main-nav ul li { margin-left: 0; margin-right: 15px; margin-bottom: 5px; }
             .main-nav ul li a { padding: 6px 10px; font-size: 1em; }
            main { padding-top: 150px; } /* Adjusted for potentially taller nav */

            .hero-container { height: 55vh; min-height: 400px; }
            .hero-text-overlay { padding: 30px; }
            .hero-text-overlay h1 { font-size: 2em; }
            h1 { font-size: 1.9em; } h2 { font-size: 1.6em; }
            .content-container { padding: 25px; }

            #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
            #result-visuals .image-placeholder img { height: 150px; }
            #result-moodboard .image-placeholder img { height: 120px; }

            .btn-back { position: relative; bottom: auto; left: auto; margin: 30px auto 0 auto; display: block; width: fit-content; }
             #home-page .btn-back { display: none; }
            .page { padding-bottom: 30px; padding-left: 15px; padding-right: 15px; }
             .budget-columns-container { gap: 15px; } /* Reduce gap on smaller screens */
             .budget-column { padding: 15px; }
        }

        @media (max-width: 480px) {
            main { padding-top: 140px; } /* Adjusted */
            .hero-container { height: 50vh; min-height: 350px; }
            .hero-text-overlay { padding: 25px; max-width: 90%; }
            .hero-text-overlay h1 { font-size: 1.7em; }
            .btn { padding: 12px 22px; font-size: 1em; margin: 8px 5px;}
            #get-suggestions-button { max-width: 90%; padding: 14px 25px; font-size: 1.1em; }
            .form-group input[type="text"], .form-group textarea, .form-group select { padding: 12px; }
            .audio-input-group { flex-direction: column; align-items: stretch; }
            .form-group input[type="file"] { margin-bottom: 10px; }
             .audio-input-group .btn { width: 100%; margin: 5px 0;}
             #record-status { margin: 5px 0 10px 0; text-align: center; }
            #result-visuals .image-placeholder-container { grid-template-columns: 1fr; } /* Single column */
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); }
            #result-visuals .image-placeholder img { height: 160px; } /* Adjust height for single column */
            #result-moodboard .image-placeholder img { height: 110px; }
            .content-container { padding: 20px; }
             .result-section { padding: 20px; }
             h1 { font-size: 1.7em; } h2 { font-size: 1.5em; }
            .optional-notice { margin-left: 0; margin-top: 5px; display: block; text-align: center; }
            #record-status { margin-left: 0; justify-content: center; width: 100%; margin-top: 5px; }
        }

    </style>
</head>
<body>

    <nav class="main-nav">
        <!-- Make sure logo image exists or update src -->
        <img src="logofinal(white).png" alt="MV Assistant Logo" class="logo-placeholder" onerror="this.alt='Logo'; this.style.backgroundColor='#555'; this.style.color='white'; this.src=''; this.style.display='inline-block';"> <!-- Added onerror fallback -->
        <ul>
            <li><a data-page="home" class="nav-link active">Home</a></li>
            <li><a data-page="about" class="nav-link">About</a></li>
            <li><a data-page="feature" class="nav-link">Feature</a></li>
        </ul>
    </nav>

    <main>
        <!-- Home Page Section -->
        <section id="home-page" class="page active">
            <div class="hero-container">
                 <!-- Make sure hero image exists or update src -->
                <img src="heroimg.jpg" alt="Abstract music visuals" class="hero-image" onerror="this.style.display='none'; this.parentElement.style.backgroundColor='#ccc';"> <!-- Added onerror fallback -->
                <div class="hero-text-overlay">
                    <h1>Get your MV suggestion based on your lyrics!</h1>
                    <button id="explore-button" class="btn btn-primary">Explore now</button>
                </div>
            </div>
            <!-- Removed duplicate back button from home -->
        </section>

        <!-- About Page Section -->
        <section id="about-page" class="page">
            <div class="content-container">
                <h2>About Us</h2>
                <p>
                    Welcome to the MV Assistant! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, and genre, MV Assistant generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, and color palettes. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!
                </p>
            </div>
            <button class="btn btn-secondary btn-back" data-target="home">Go Back</button>
        </section>

        <!-- Feature Page Section -->
        <section id="feature-page" class="page">
            <div class="content-container">
                <h1>MV Assistant</h1>

                <form id="feature-form" onsubmit="return false;">
                    <!-- Form groups remain the same -->
                    <div class="form-group">
                        <label for="lyrics-input">Music Lyrics:</label>
                        <textarea id="lyrics-input" rows="7" placeholder="Paste your complete song lyrics here..." required></textarea> <!-- Added required -->
                    </div>
                    <div class="form-group">
                        <label for="keywords-input">Keywords / Theme:</label>
                        <input type="text" id="keywords-input" placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle, first love" required> <!-- Added required -->
                    </div>
                    <div class="form-group">
                        <label for="genre-select">Music Genre:</label>
                        <select id="genre-select" required>
                            <option value="" disabled selected>-- Select a Genre --</option>
                            <option value="RnB">RnB / Soul</option>
                            <option value="Folk">Folk / Acoustic</option>
                            <option value="Rock">Rock (Alternative, Hard Rock, etc.)</option>
                            <option value="Pop">Pop (Synth-pop, Dance-pop, etc.)</option>
                            <option value="Hiphop">Hip-hop / Rap</option>
                            <option value="Electronic">Electronic (EDM, House, Techno)</option>
                            <option value="Classical">Classical / Orchestral</option>
                            <option value="Country">Country</option>
                             <option value="Jazz">Jazz / Blues</option>
                             <option value="Reggae">Reggae / Dancehall</option>
                             <option value="Metal">Metal</option>
                            <option value="Other">Other / Fusion</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="track-upload">Track Input (Optional):</label>
                        <div class="audio-input-group">
                             <input type="file" id="track-upload" accept="audio/*">
                             <button type="button" id="record-audio-button" class="btn btn-warning">Record Audio</button>
                             <span class="optional-notice">(Optional)</span>
                             <span id="record-status" class="record-status-base"> <!-- Added base class for potential styling -->
                                 <span id="recording-animation" class="recording-dots" style="display: none;"><span></span><span></span><span></span></span> <!-- Emptied dots for CSS animation -->
                                 <span id="record-status-text"></span>
                             </span>
                        </div>
                        <small>Note: Audio analysis (upload/record) requires browser support for recording & speech recognition. Suggestions are primarily based on text inputs + transcript.</small>
                    </div>
                    <div class="form-group" id="transcript-group" style="display: none;">
                        <label for="transcript-output">Singing Transcript (from recording):</label>
                        <textarea id="transcript-output" rows="4" readonly placeholder="Transcript will appear here after recording..."></textarea>
                        <small>This text will be analyzed along with lyrics.</small>
                    </div>

                    <button type="button" id="get-suggestions-button" class="btn btn-primary">Get Suggestions!</button>
                </form>

                <div id="loading-indicator" style="display: none;">
                    <p>Generating creative suggestions... This might take a few moments.</p>
                    <div class="spinner"></div>
                </div>

                <div id="error-message" class="error-message"></div>

                <!-- Results Area Structure - Ensure correct sub-containers exist -->
                <div id="results-area">
                     <section id="result-concept" class="result-section"><h2>Concept / Key Visual</h2><div class="content"><p></p></div></section>
                     <section id="result-requirements" class="result-section"><h2>Requirements for MV</h2><div class="content"><ul></ul></div></section>
                     <section id="result-budget" class="result-section"><h2>Estimated Budget</h2><div class="content"><div class="budget-columns-container"></div></div></section>
                     <section id="result-visuals" class="result-section">
                         <h2>Visual Demo (Key Image Ideas)</h2>
                         <div class="content">
                             <div class="image-placeholder-container"></div> <!-- Ensure this container exists -->
                         </div>
                         <small>Note: Images are illustrative examples fetched based on AI descriptions. Actual MV visuals require specific direction.</small>
                     </section>
                     <section id="result-moodboard" class="result-section">
                         <h2>Moodboard Influences</h2>
                          <div class="content">
                              <p id="moodboard-description"></p> <!-- Ensure this exists -->
                              <div class="image-placeholder-container" id="moodboard-images"></div> <!-- Ensure this exists with ID -->
                         </div>
                          <small>Note: Images are illustrative examples fetched based on AI descriptions. Actual MV visuals require specific direction.</small>
                     </section>
                     <section id="result-palette" class="result-section">
                         <h2>Color Palette</h2>
                         <div class="content">
                            <div class="color-palette-display"></div> <!-- Ensure this container exists -->
                         </div>
                     </section>
                </div>

            </div>
             <button class="btn btn-secondary btn-back" data-target="home">Go Back</button>
        </section>
    </main>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element References ---
        const navLinks = document.querySelectorAll('.nav-link');
        const pages = document.querySelectorAll('.page');
        const exploreButton = document.getElementById('explore-button');
        const backButtons = document.querySelectorAll('.btn-back');
        const getSuggestionsButton = document.getElementById('get-suggestions-button');
        const resultsArea = document.getElementById('results-area');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessageDiv = document.getElementById('error-message');
        const recordAudioButton = document.getElementById('record-audio-button');
        const recordStatus = document.getElementById('record-status');
        const recordingAnimation = document.getElementById('recording-animation');
        const recordStatusText = document.getElementById('record-status-text');
        const lyricsInput = document.getElementById('lyrics-input');
        const keywordsInput = document.getElementById('keywords-input');
        const genreSelect = document.getElementById('genre-select');
        const trackUploadInput = document.getElementById('track-upload');
        const transcriptGroup = document.getElementById('transcript-group');
        const transcriptOutput = document.getElementById('transcript-output');
        const heroImage = document.querySelector('.hero-image'); // For parallax

        // --- Audio Recording Variables ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordedAudioBlob = null;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let finalTranscript = '';
        let isSpeechRecognitionSupported = !!SpeechRecognition;

        // --- Page Navigation ---
        function showPage(pageId) {
            pages.forEach(page => page.classList.remove('active'));
            const targetPage = document.getElementById(`${pageId}-page`);
            if (targetPage) {
                targetPage.classList.add('active');
            } else {
                console.error("Target page not found:", pageId);
                document.getElementById('home-page').classList.add('active'); // Fallback to home
                pageId = 'home';
            }
            // Update nav links
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('data-page') === pageId) {
                    link.classList.add('active');
                }
            });
            window.scrollTo(0, 0); // Scroll to top
            // Handle parallax visibility
            if (heroImage) handleScrollParallax(); // Recalculate parallax on page change
        }

        // --- Microphone Recording Logic ---
        if (recordAudioButton) {
            recordAudioButton.addEventListener('click', handleRecordButtonClick);
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateRecordStatus('Audio recording not supported.', 'error');
                recordAudioButton.disabled = true;
            } else if (!isSpeechRecognitionSupported) {
                updateRecordStatus('Speech recognition not supported.', 'error');
                console.warn("Speech Recognition not supported.");
                // Recording might still work, don't disable button
            }
        } else {
            console.warn("Record audio button not found.");
        }

        async function handleRecordButtonClick() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateRecordStatus('Recording not supported by browser.', 'error');
                return;
            }
            if (!isRecording) {
                // Start Recording
                try {
                    recordedAudioBlob = null; // Reset previous recording
                    trackUploadInput.value = ''; // Clear file input if user records instead
                    transcriptOutput.value = ''; // Clear previous transcript
                    finalTranscript = '';
                    transcriptGroup.style.display = 'none';
                    updateRecordStatus('Requesting mic access...', '');

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    updateRecordStatus('', 'recording'); // Update status after permission granted
                    mediaRecorder = new MediaRecorder(stream);

                    // Setup MediaRecorder events
                    mediaRecorder.ondataavailable = event => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        console.log("MediaRecorder stopped.");
                        if (audioChunks.length > 0) {
                            recordedAudioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                            console.log("Recording finished. Blob size:", recordedAudioBlob.size);
                            // Update status only if speech recognition isn't running or failed
                            if (!recognition || (recognition && recognition.readyState !== 'listening' && recognition.readyState !== 'pending')) {
                                updateRecordStatus(`Recording complete (${(recordedAudioBlob.size / 1024).toFixed(1)} KB).`, 'complete');
                            }
                        } else {
                            console.log("Recording stopped with no data chunks.");
                            if (!recognition || (recognition && recognition.readyState !== 'listening' && recognition.readyState !== 'pending')) {
                                updateRecordStatus('Stopped (no audio captured).', 'error');
                            }
                             recordedAudioBlob = null;
                        }
                        audioChunks = []; // Clear chunks for next recording
                        stream.getTracks().forEach(track => track.stop()); // Release microphone
                        updateRecordingUI(false);
                    };

                    mediaRecorder.onerror = (event) => {
                        console.error("MediaRecorder error:", event.error);
                        updateRecordStatus(`Recording error: ${event.error.name}`, 'error');
                        if (recognition && (recognition.readyState === 'listening' || recognition.readyState === 'pending')) {
                            recognition.stop();
                        }
                        stream.getTracks().forEach(track => track.stop());
                        updateRecordingUI(false);
                    };

                    // Setup SpeechRecognition if supported
                    if (isSpeechRecognitionSupported) {
                        recognition = new SpeechRecognition();
                        recognition.continuous = true; // Keep listening
                        recognition.interimResults = true; // Show results as they come
                        recognition.lang = 'en-US'; // Set language

                        recognition.onresult = (event) => {
                            let interimTranscript = '';
                            finalTranscript = ''; // Rebuild final transcript each time
                            for (let i = event.resultIndex; i < event.results.length; ++i) {
                                if (event.results[i].isFinal) {
                                    finalTranscript += event.results[i][0].transcript + ' ';
                                } else {
                                    interimTranscript += event.results[i][0].transcript;
                                }
                            }
                            const currentFullTranscript = (finalTranscript + interimTranscript).trim();
                            transcriptOutput.value = currentFullTranscript;
                            if (currentFullTranscript) {
                                transcriptGroup.style.display = 'block'; // Show transcript area
                            }
                        };

                        recognition.onerror = (event) => {
                            console.error("Speech Recognition Error:", event.error);
                            let errorMsg = `Transcription error: ${event.error}`;
                            if (event.error === 'no-speech') errorMsg = 'No speech detected during transcription.';
                            else if (event.error === 'audio-capture') errorMsg = 'Mic problem during transcription.';
                            else if (event.error === 'not-allowed') errorMsg = 'Transcription permission denied.';
                            else if (event.error === 'network') errorMsg = 'Network error during transcription.';

                             // Update status only if we are still in "recording" state visually
                             if (isRecording) {
                                updateRecordStatus(errorMsg, 'error');
                             } else { // If recording stopped before error, show simpler message
                                updateRecordStatus('Transcription issue occurred.', 'error');
                             }
                        };

                        recognition.onend = () => {
                            console.log("Speech recognition ended.");
                            finalTranscript = finalTranscript.trim();
                            transcriptOutput.value = finalTranscript; // Ensure final is set

                            // Update status based on whether we got a transcript and/or audio
                             if (!isRecording) { // Only update final status if stop button was pressed
                                if (finalTranscript && recordedAudioBlob) {
                                    updateRecordStatus('Recording & Transcription Complete.', 'complete');
                                } else if (finalTranscript && !recordedAudioBlob) {
                                    // This case shouldn't normally happen if recording started ok
                                    updateRecordStatus('Transcription Complete (No Recording Saved).', 'complete');
                                } else if (!finalTranscript && recordedAudioBlob) {
                                    updateRecordStatus(`Recording complete. No transcript generated.`, 'complete');
                                } else {
                                    // If status wasn't already set to an error
                                    if (!recordStatus || !recordStatus.classList.contains('error')) { // Check recordStatus exists
                                       updateRecordStatus('Stopped.', '');
                                    }
                                }
                             }
                        };

                        recognition.start();
                        console.log("Speech recognition started.");
                        updateRecordStatus('', 'transcribing'); // Indicate transcription process
                    } else {
                        updateRecordStatus('', 'recording'); // Just show recording if no speech rec
                    }

                    // Start recording
                    audioChunks = [];
                    mediaRecorder.start();
                    updateRecordingUI(true);
                    console.log("MediaRecorder started.");

                } catch (err) {
                    console.error("Error accessing microphone or starting recording:", err);
                    let errorMsg = `Mic access error: ${err.name || err.message}`;
                    if (err.name === 'NotAllowedError' || err.message.includes('Permission denied')) {
                        errorMsg = 'Microphone permission denied.';
                    } else if (err.name === 'NotFoundError') {
                        errorMsg = 'No microphone found.';
                    } else if (err.name === 'NotReadableError') {
                        errorMsg = 'Microphone is already in use or hardware error.';
                    }
                    updateRecordStatus(errorMsg, 'error');
                    updateRecordingUI(false);
                }
            } else {
                // Stop Recording
                if (mediaRecorder && mediaRecorder.state === "recording") {
                    updateRecordStatus('Stopping...', ''); // Intermediate state
                    mediaRecorder.stop();
                }
                if (recognition && (recognition.readyState === 'listening' || recognition.readyState === 'pending')) {
                    recognition.stop();
                }
                 // UI update and final status handled by onstop/onend events
            }
        }

        function updateRecordingUI(recording) {
            if (!recordAudioButton) return;
            isRecording = recording;
            if (recording) {
                recordAudioButton.textContent = 'Stop Recording';
                recordAudioButton.classList.remove('btn-warning');
                recordAudioButton.classList.add('btn-danger');
                if(recordingAnimation) recordingAnimation.style.display = 'inline-block';
            } else {
                recordAudioButton.textContent = 'Record Audio';
                recordAudioButton.classList.remove('btn-danger');
                recordAudioButton.classList.add('btn-warning');
                if(recordingAnimation) recordingAnimation.style.display = 'none';
            }
        }

        function updateRecordStatus(message, statusClass = '') {
            if (!recordStatus || !recordStatusText || !recordingAnimation) return;

            recordStatusText.textContent = message;
            // Reset all classes first
            recordStatus.className = ''; // Clear all classes first
            recordStatus.classList.add('record-status-base'); // Add a base class if needed for consistent styling
            if (statusClass) {
                recordStatus.classList.add(statusClass);
            }

            // Show animation only for 'recording' or 'transcribing' that implies recording
            if (statusClass === 'recording' || statusClass === 'transcribing') {
                recordingAnimation.style.display = 'inline-block';
                 if(statusClass === 'recording') recordStatusText.textContent = ''; // Hide text if just 'recording'
            } else {
                recordingAnimation.style.display = 'none';
            }
        }


        if(trackUploadInput) {
             trackUploadInput.addEventListener('change', () => {
                 if (trackUploadInput.files.length > 0) {
                     // Stop recording if active
                     if (isRecording && mediaRecorder && mediaRecorder.state === "recording") {
                         mediaRecorder.stop();
                         if(recognition && (recognition.readyState === 'listening' || recognition.readyState === 'pending')) recognition.stop();
                     }
                     // Reset state associated with recording
                     updateRecordStatus('', ''); // Clear status message
                     recordedAudioBlob = null; // Discard any recorded blob
                     transcriptOutput.value = ''; // Clear transcript
                     finalTranscript = '';
                     transcriptGroup.style.display = 'none';
                     updateRecordingUI(false); // Ensure button is in 'Record' state
                     console.log("File selected via input, cleared recording state.");
                 }
             });
        }

        // --- Get Suggestions Logic ---
        async function handleGetSuggestions() {
            // --- !! EXTREME SECURITY WARNING: KEYS EMBEDDED !! ---
            // --- !! DO NOT USE IN PRODUCTION CODE !! ---
            // --- !! MOVE API CALLS TO A BACKEND SERVER !! ---
            const GEMINI_API_KEY = "AIzaSyB5c-hp-QeKBpBTz8qwANe4j5Kc4dZ_bWM"; // <-- INSECURE GEMINI KEY - FOR STUDY ONLY
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
            // --- !! END WARNING !! ---

            const lyrics = lyricsInput.value.trim();
            const keywords = keywordsInput.value.trim();
            const selectedGenre = genreSelect.value;
            const singingTranscript = transcriptOutput.value.trim(); // Use finalTranscript? Maybe safer if output is lagging? Let's use output for now.

            // Simple Validation
            if (!lyrics) { displayError("Please provide the song lyrics."); return; }
            if (!keywords) { displayError("Please enter some keywords or describe the theme."); return; }
            if (!selectedGenre) { displayError("Please select a music genre from the list."); return; }

            clearResultsAndErrors();
            loadingIndicator.style.display = 'block';
            getSuggestionsButton.disabled = true;
            getSuggestionsButton.textContent = 'Thinking...';

            // --- *** PROMPT Structure (Keep as defined in your working version) *** ---
            let basePromptStructure = `
You are an AI assistant specialized in generating creative concepts for music videos. Analyze the provided song details (lyrics, keywords, genre, optional singing transcript) and generate comprehensive, structured suggestions.

Structure your response EXACTLY like this, using markdown headers (##) for each section:

## Concept / Key Visual
(Provide a concise, compelling core concept description. Mention 1-2 key visual motifs or scenes that capture the essence.)

## Requirements for MV
(List specific, practical requirements needed to execute the concept using bullet points (*). Be detailed. Include elements like:
*   Location(s): [Specific types, e.g., abandoned warehouse, sunlit field, neon-lit city street at night]
*   Casting: [Number of actors, specific types/roles, e.g., main artist performance, 2 dancers, extras for crowd scene]
*   Props: [Key objects needed, e.g., vintage car, specific type of flower, symbolic item from lyrics]
*   Wardrobe Style: [Describe the clothing aesthetic, e.g., streetwear, bohemian, futuristic formal]
*   Cinematography Style: [Describe camera work/lighting, e.g., handheld & gritty, slow-motion & ethereal, high contrast shadows]
*   Key Visual Effects (if any): [e.g., color grading, light leaks, subtle particle effects, compositing needs]
*   Editing Style: [e.g., fast-paced cuts, slow crossfades, match cuts])

## Estimated Budget
(Provide a conceptual budget breakdown using bullet points (*). Describe what each level visually enables. **Crucially, for each level (Low, Mid, High), include a very rough estimated total cost range in USD (e.g., Low: $500 - $2,000, Mid: $5,000 - $15,000, High: $25,000+).** Also, within the description for each level, **try to mention example cost factors** for key elements if possible, e.g., Location: $X, Casting: $Y.)
*   **Low Budget:** [Describe focused scope... Include rough total USD range and potentially element cost factors.]
*   **Mid Budget:** [Describe balanced scope... Include rough total USD range and potentially element cost factors.]
*   **High Budget:** [Describe ambitious scope... Include rough total USD range and potentially element cost factors.]

## Visual Demo (Key Image Descriptions)
(Describe 3-5 distinct key shots or visual moments from the potential video as if describing images. Use numbered points (1., 2., 3.). Be descriptive enough for an image generation AI or moodboard search. Example:
1.  Wide shot of the singer standing alone on a misty pier at dawn, looking out at the water.
2.  Extreme close-up on hands intertwining, silhouetted against a vibrant sunset.
3.  Fast-paced montage of blurry city lights seen from a moving car at night.)

## Moodboard Influences
(Describe the overall aesthetic mood first. Then list 4-6 specific visual elements, textures, artists, films, or styles that inform the moodboard using bullet points (*). Example:
*   The color palette of Wes Anderson films
*   Grainy texture of old Super 8 footage
*   Dramatic lighting found in film noir
*   Close-up shots focusing on hands and expressions
*   [Optional Element 5 Description]
*   [Optional Element 6 Description])

## Color Palette
(Suggest 4-6 key colors that fit the mood. List them with names and HEX codes. Format *exactly* like this: Color Name (#XXXXXX), Another Color (#XXXXXX), Third Color (#XXXXXX). Commas are optional between colors, but Name (#HEX) format is crucial.)

Adhere strictly to this format and provide detailed, relevant content for each section based on the input song details. Ensure the budget section includes the requested USD cost ranges and element factors.
`;

             let fullPrompt = `
Analyze the following song details:

**Lyrics:**
\`\`\`
${lyrics}
\`\`\`
`;
            if (singingTranscript) {
                fullPrompt += `
**Singing Transcript (from recording):**
\`\`\`
${singingTranscript}
\`\`\`
`;
            }
            fullPrompt += `
**Keywords/Theme:** ${keywords}
**Music Genre:** ${selectedGenre}

Based on *all* the provided text details, generate detailed and actionable music video suggestions. Structure your response *exactly* as follows, using markdown headers (##):
${basePromptStructure}
             `;


            const requestBody = {
                contents: [{ parts: [{ text: fullPrompt }] }],
                generationConfig: {
                    temperature: 0.75,
                    maxOutputTokens: 4096 // Increased slightly for potentially longer budget descriptions
                 },
                 safetySettings: [ // Standard safety settings
                   { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                 ]
            };

            try {
                console.log("Sending API request to Gemini...");
                // console.log("Request Body:", JSON.stringify(requestBody, null, 2)); // Optional: Log request body for debugging

                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                 });

                const responseData = await response.json();
                 console.log("Raw API Response:", responseData); // Log raw response for debugging

                // --- Error Handling ---
                if (!response.ok) {
                    const errorDetail = responseData?.error?.message || `HTTP Error: ${response.status}`;
                    const safetyFeedback = responseData?.promptFeedback?.blockReason;
                    let errorMessage = `Gemini API Error: ${errorDetail}`;
                    if (safetyFeedback) {
                        errorMessage += ` (Reason: ${safetyFeedback})`;
                    }
                    console.error("Gemini API Error Details:", responseData);
                    throw new Error(errorMessage);
                }

                const candidate = responseData?.candidates?.[0];
                if (!candidate) {
                     if (responseData?.promptFeedback?.blockReason) {
                        throw new Error(`Request blocked by safety settings. Reason: ${responseData.promptFeedback.blockReason}`);
                    }
                    throw new Error("No response candidate found from the AI.");
                 }

                 // Check finish reason
                if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
                    const reason = candidate.finishReason;
                    const safetyRatings = candidate.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ');
                    throw new Error(`Generation failed or was stopped. Reason: ${reason}. ${safetyRatings ? `Safety Issues: [${safetyRatings}]` : ''}`);
                 }

                if (candidate?.content?.parts?.[0]?.text) {
                    const generatedText = candidate.content.parts[0].text;
                    console.log("Received Gemini response text.");
                    parseAndDisplayResults(generatedText);
                 } else {
                    console.error("Unexpected response format:", responseData);
                    throw new Error("Received an unexpected or empty response format from the AI.");
                 }

            } catch (error) {
                console.error("Error during Gemini fetch or processing:", error);
                displayError(`Failed to get suggestions. ${error.message}. Please check the console for details.`);
            } finally {
                loadingIndicator.style.display = 'none';
                getSuggestionsButton.disabled = false;
                getSuggestionsButton.textContent = 'Get Suggestions!';
            }
        }

        // --- Parsing and Displaying Results ---
        function parseAndDisplayResults(text) {
            clearResultsAndErrors();
            console.log("Parsing AI response...");
            // Define section titles exactly as expected in the AI output (based on the prompt)
            const sections = {
                'Concept / Key Visual': 'result-concept',
                'Requirements for MV': 'result-requirements',
                'Estimated Budget': 'result-budget',
                'Visual Demo (Key Image Descriptions)': 'result-visuals',
                'Moodboard Influences': 'result-moodboard',
                'Color Palette': 'result-palette'
            };

            // Split the response into lines for processing
            const lines = text.split('\n');
            let currentSectionKey = null;
            let contentBuffer = '';
            let foundAnySection = false;

            lines.forEach(line => {
                let matchedHeader = false;
                for (const title in sections) {
                    // Regex to match "## Section Title" at the start of a line, ignoring whitespace
                    const headerRegex = new RegExp(`^\\s*##\\s*${title.trim().replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*$`, 'i');
                    if (headerRegex.test(line.trim())) {
                        // If we were already processing a section, finalize it
                        if (currentSectionKey && contentBuffer.trim()) {
                            processSectionContent(sections[currentSectionKey], currentSectionKey, contentBuffer.trim());
                            foundAnySection = true;
                        }
                        // Start the new section
                        currentSectionKey = title;
                        contentBuffer = ''; // Reset buffer for the new section
                        matchedHeader = true;
                        break; // Stop checking other titles for this line
                    }
                }
                // If it's not a header line and we are inside a section, add it to the buffer
                if (!matchedHeader && currentSectionKey) {
                    contentBuffer += line + '\n';
                }
            });

            // Process the very last section after the loop finishes
            if (currentSectionKey && contentBuffer.trim()) {
                processSectionContent(sections[currentSectionKey], currentSectionKey, contentBuffer.trim());
                foundAnySection = true;
            }

            // Display the results area if we successfully parsed at least one section
            if (foundAnySection) {
                console.log("Parsing complete, displaying results area.");
                resultsArea.style.display = 'block';
                // Scroll smoothly to the results
                resultsArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } else {
                // If no sections were parsed, display an error and log the raw text
                displayError("Could not parse the AI response structure. The response might be empty or not follow the expected format. Raw output logged to console.");
                console.warn("Raw AI Response Text (Parsing Failed):", text);
            }
        }

        // --- *** Unsplash Image Function (with robust fallback) *** ---
        // --- !! SECURITY WARNING: KEYS EMBEDDED !! ---
        const UNSPLASH_ACCESS_KEY = 'tKEVJi06udyaqpZiOkTKrpLNw6uZfT81dLdfvDcotAM'; // <-- INSECURE UNSPLASH KEY
        // --- !! END WARNING !! ---

        async function createImagePlaceholder(container, description, seedSuffix) {
             const figure = document.createElement('figure');
             figure.className = 'image-placeholder';

             const img = document.createElement('img');
             img.style.backgroundColor = '#e9ecef'; // Placeholder color
             img.alt = `Loading image for: ${description}`;
             img.src = ''; // Start empty
             img.loading = 'lazy'; // Lazy load images

             // Determine correct height based on container type
             let placeholderHeight = 180; // Default (Visuals)
             if (container && container.closest('#result-moodboard')) {
                 placeholderHeight = 140; // Moodboard height
             }
             img.style.height = `${placeholderHeight}px`;
             img.style.width = '100%';
             img.style.objectFit = 'cover';

             const figcaption = document.createElement('figcaption');
             // Basic markdown bold handling for caption
             figcaption.innerHTML = description.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

             figure.appendChild(img);
             figure.appendChild(figcaption);
             container.appendChild(figure);

             // Check if key is missing or looks like a placeholder
             if (!UNSPLASH_ACCESS_KEY || UNSPLASH_ACCESS_KEY.startsWith('YOUR_') || UNSPLASH_ACCESS_KEY.length < 20) {
                 console.warn("Unsplash Key invalid or missing. Using placeholder image.");
                 setFallbackImage(img, figcaption, description, seedSuffix, 'no-key', placeholderHeight);
                 return;
             }

             try {
                // Sanitize and shorten query
                let query = description.replace(/<[^>]*>/g, '').replace(/[^a-zA-Z0-9\s,.]/g, '').trim(); // Remove HTML and most symbols
                query = query.length > 60 ? query.substring(0, 60).split(' ').slice(0, -1).join(' ') : query; // Limit length nicely
                if (!query) {
                    console.warn("Empty image description after sanitization. Using fallback.");
                    setFallbackImage(img, figcaption, description, seedSuffix, 'empty-query', placeholderHeight);
                    return;
                 }

                const searchUrl = `https://api.unsplash.com/search/photos?query=${encodeURIComponent(query)}&per_page=1&orientation=landscape&client_id=${UNSPLASH_ACCESS_KEY}`;
                console.log(`Fetching Unsplash: Query='${query}', URL='${searchUrl}'`);

                const response = await fetch(searchUrl);
                const responseData = await response.json(); // Read body once

                console.log(`Unsplash Response Status: ${response.status}, OK: ${response.ok}`);
                // console.log("Unsplash Response Data:", responseData); // Optional: Log full response

                if (!response.ok) {
                    let errorMsg = `Unsplash API error: ${response.status}`;
                    if (responseData && responseData.errors) errorMsg += ` - ${responseData.errors[0]}`;
                    console.error(errorMsg, `for query "${query}"`);
                    setFallbackImage(img, figcaption, description, seedSuffix, 'api-error', placeholderHeight);
                    return; // Stop here on API error
                 }

                if (responseData.results && responseData.results.length > 0) {
                    const imageResult = responseData.results[0];
                    img.src = imageResult.urls.small; // Use small URL for placeholders
                    img.alt = imageResult.alt_description || description; // Use API alt text if available

                    // Add attribution link
                    const attributionLink = document.createElement('a');
                    attributionLink.href = imageResult.links.html + '?utm_source=mv_assistant&utm_medium=referral';
                    attributionLink.target = '_blank';
                    attributionLink.rel = 'noopener noreferrer';
                    attributionLink.innerHTML = `Photo by <span style="text-decoration: underline;">${imageResult.user.name}</span> on <span style="text-decoration: underline;">Unsplash</span>`;
                    figcaption.appendChild(attributionLink);
                } else {
                    console.warn(`No Unsplash image found for: "${query}". Using placeholder.`);
                    setFallbackImage(img, figcaption, description, seedSuffix, 'not-found', placeholderHeight);
                }
             } catch (error) {
                console.error(`Failed to fetch/process Unsplash image for "${description}":`, error);
                setFallbackImage(img, figcaption, description, seedSuffix, 'fetch-error', placeholderHeight);
             }
        }

        function setFallbackImage(imgElement, figcaptionElement, description, seedSuffix, reason, height) {
             // Use a deterministic seed based on description and suffix for consistent placeholders
            const seed = encodeURIComponent(description.substring(0, 25) + seedSuffix + '-' + reason);
            // Use the determined height for the placeholder URL
            const picSumHeight = Math.round(height * 1.5); // Adjust multiplier if needed for aspect ratio
            imgElement.src = `https://picsum.photos/seed/${seed}/400/${picSumHeight}`;
            imgElement.alt = `Placeholder image representing: ${description}`;

            // Add a visual notice in the caption
            const fallbackNotice = document.createElement('span');
            fallbackNotice.className = 'fallback-notice';
            fallbackNotice.textContent = `(Placeholder: ${reason})`; // Show reason
            // Add notice before any existing links
            if (figcaptionElement.querySelector('a')) {
                figcaptionElement.insertBefore(fallbackNotice, figcaptionElement.querySelector('a'));
            } else {
                figcaptionElement.appendChild(fallbackNotice);
            }
        }


        // --- *** Process Section Content Function (Handles different sections) *** ---
        function processSectionContent(elementId, sectionTitle, content) {
            const sectionElement = document.getElementById(elementId);
            if (!sectionElement) { console.error(`Section element not found: ${elementId}`); return; }

            const contentDiv = sectionElement.querySelector('.content');
            if (!contentDiv) { console.error(`Content div not found in: ${elementId}`); return; }

            // Clear previous content for most sections before processing (specific containers cleared below)
            contentDiv.innerHTML = '';

            try {
                console.log(`Processing Section: ${sectionTitle}`);

                if (sectionTitle === 'Visual Demo (Key Image Descriptions)') {
                    // --- Handle Visual Demo ---
                    let imageContainer = contentDiv.querySelector('.image-placeholder-container'); // Use let
                     if (!imageContainer) {
                         // If container doesn't exist, create it (more robust)
                         console.warn(`Image container (.image-placeholder-container) not found within ${elementId}, creating it.`);
                         imageContainer = document.createElement('div');
                         imageContainer.className = 'image-placeholder-container';
                         // Apply grid styles dynamically if needed, or rely on CSS
                         if (elementId === 'result-visuals') imageContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(220px, 1fr))';
                         contentDiv.appendChild(imageContainer); // Add it to the content div
                     }
                    imageContainer.innerHTML = ''; // Clear previous images

                    // Match numbered list items more robustly (allows multi-digit numbers)
                    const descriptions = content.split(/^\s*[1-9][0-9]*\.\s+/gm).filter(Boolean).map(d => d.trim().replace(/\n$/, ''));
                    console.log(`Found ${descriptions.length} visual descriptions:`, descriptions);

                    if (descriptions.length > 0) {
                        descriptions.forEach((desc, index) => {
                            if (desc) { // Ensure description is not empty
                                createImagePlaceholder(imageContainer, desc, `visual-${index}-${Date.now()}`);
                            }
                        });
                    } else {
                       imageContainer.innerHTML = `<p style="font-style: italic; color: #6c757d;">No specific visual descriptions found in the expected format (e.g., 1., 2., 3.).</p>`;
                    }
                    // Make sure the parent content div is visible if needed (should be by default unless cleared entirely)
                    contentDiv.style.display = 'block';


                } else if (sectionTitle === 'Moodboard Influences') {
                    // --- Handle Moodboard ---
                    // Find or create necessary elements
                    let descriptionElement = contentDiv.querySelector('#moodboard-description');
                    if (!descriptionElement) {
                        console.warn("Moodboard description element not found, creating.");
                        descriptionElement = document.createElement('p');
                        descriptionElement.id = 'moodboard-description';
                        contentDiv.appendChild(descriptionElement);
                    }
                    let imageContainer = contentDiv.querySelector('#moodboard-images');
                     if (!imageContainer) {
                        console.warn("Moodboard image container element not found, creating.");
                        imageContainer = document.createElement('div');
                        imageContainer.className = 'image-placeholder-container';
                        imageContainer.id = 'moodboard-images';
                         // Apply grid styles dynamically if needed, or rely on CSS
                         imageContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(180px, 1fr))';
                        contentDiv.appendChild(imageContainer); // Add it to the content div
                    }
                    // Clear previous content specifically
                    imageContainer.innerHTML = '';
                    descriptionElement.textContent = '';
                    // Ensure they are in the right order (Description first)
                    contentDiv.insertBefore(descriptionElement, imageContainer);

                    // Find the first bullet point to separate description from items
                    const firstBulletMatch = content.match(/^\s*[\*\-]\s+/m);
                    let mainDescription = content.trim();
                    let itemsToProcess = [];

                    if (firstBulletMatch) {
                        mainDescription = content.substring(0, firstBulletMatch.index).trim();
                        // Split the rest by bullet points (* or - at start of line)
                        itemsToProcess = content.substring(firstBulletMatch.index).split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(b => b.trim().replace(/\n$/, ''));
                        console.log(`Found moodboard description: "${mainDescription}"`);
                        console.log(`Found ${itemsToProcess.length} moodboard item descriptions:`, itemsToProcess);
                    } else {
                        // No bullet points found, assume entire content is the description
                        console.log("No moodboard bullet points found, using full text as description:", mainDescription);
                    }

                    descriptionElement.textContent = mainDescription;
                    descriptionElement.style.display = mainDescription ? 'block' : 'none'; // Show only if description exists

                    if (itemsToProcess.length > 0) {
                        itemsToProcess.forEach((desc, index) => {
                            if (desc) {
                                createImagePlaceholder(imageContainer, desc, `mood-${index}-${Date.now()}`);
                            }
                        });
                    } else if (!mainDescription) {
                       // Show message only if there are no items AND no description
                       imageContainer.innerHTML = `<p style="font-style: italic; color: #6c757d;">No moodboard description or items found.</p>`;
                    }


                } else if (sectionTitle === 'Estimated Budget') {
                    // --- Handle Budget Section (Columns) ---
                    contentDiv.innerHTML = ''; // Clear placeholder content
                    let container = contentDiv.querySelector('.budget-columns-container');
                    if(!container){
                        container = document.createElement('div');
                        container.className = 'budget-columns-container';
                        contentDiv.appendChild(container);
                    }
                    container.innerHTML = ''; // Clear previous columns

                    const budgetLevels = { "Low Budget": null, "Mid Budget": null, "High Budget": null };
                    // Regex to capture level and its description until the next level or end of string
                    // Allows optional colon after budget level name
                    const budgetRegex = /\*\s*\*\*(Low|Mid|High) Budget\*\*\s*:?\s*([\s\S]*?)(?=\n\s*\*\s*\*\*|\n*$)/g;

                    let match;
                    while ((match = budgetRegex.exec(content)) !== null) {
                        const level = match[1] + " Budget";
                        // Trim the description, handle potential markdown within later
                        const description = match[2].trim();
                        if (budgetLevels.hasOwnProperty(level)) {
                            budgetLevels[level] = description;
                            console.log(`Parsed budget level: ${level}`);
                        }
                    }

                    const order = ["Low Budget", "Mid Budget", "High Budget"];
                    let columnsCreated = 0;
                    order.forEach(level => {
                       if (budgetLevels[level]) {
                           const columnDiv = document.createElement('div');
                           columnDiv.className = 'budget-column';

                           const titleH3 = document.createElement('h3');
                           titleH3.textContent = level;

                           const descP = document.createElement('p');
                           // Apply basic markdown bolding for potential costs like **$500 - $2,000**
                           descP.innerHTML = budgetLevels[level].replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

                           columnDiv.appendChild(titleH3);
                           columnDiv.appendChild(descP);
                           container.appendChild(columnDiv);
                           columnsCreated++;
                       }
                    });

                    if (columnsCreated === 0) {
                       console.warn("Could not parse budget levels into columns using regex. Displaying raw text.");
                       // Display raw content if parsing fails, preserving line breaks
                       contentDiv.innerHTML = `<p style="white-space: pre-wrap;">${content.trim()}</p>`;
                    }

                } else if (sectionTitle === 'Requirements for MV') {
                    // --- Handle Requirements Section (List) ---
                    let listElement = contentDiv.querySelector('ul');
                    if (!listElement) {
                        listElement = document.createElement('ul');
                        contentDiv.appendChild(listElement);
                    }
                    listElement.innerHTML = ''; // Clear previous items

                    // Split by lines starting with '*' or '-'
                    const items = content.trim().split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(item => item.trim().replace(/\n$/, ''));
                    console.log(`Found ${items.length} requirement items.`);

                    if (items.length > 0) {
                        items.forEach(itemText => {
                            const li = document.createElement('li');
                            // Basic markdown bolding
                            li.innerHTML = itemText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                            listElement.appendChild(li);
                        });
                    } else {
                        // Fallback if no list items detected
                        console.warn("No requirement items found in expected list format. Displaying raw text.");
                        contentDiv.innerHTML = `<p style="white-space: pre-wrap;">${content.trim()}</p>`;
                    }

                } else if (sectionTitle === 'Color Palette') {
                    // --- Handle Color Palette ---
                    let paletteContainer = contentDiv.querySelector('.color-palette-display');
                     if (!paletteContainer) {
                         console.warn("Color palette container not found, creating.");
                         paletteContainer = document.createElement('div');
                         paletteContainer.className = 'color-palette-display';
                         contentDiv.appendChild(paletteContainer);
                     }
                    paletteContainer.innerHTML = ''; // Clear only the palette container
                    createColorSwatches(paletteContainer, content.trim()); // Populate it

                } else { // Concept / Key Visual or any other unexpected section
                    // --- Handle General Text Sections (like Concept) ---
                    // Find or create paragraph element
                     let pElement = contentDiv.querySelector('p');
                     if(!pElement){
                         pElement = document.createElement('p');
                         contentDiv.appendChild(pElement);
                     }
                    // Display text preserving whitespace and applying basic bolding
                    pElement.style.whiteSpace = 'pre-wrap';
                    pElement.innerHTML = content.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                }
                sectionElement.style.display = 'block'; // Show the processed section
            } catch (error) {
                 console.error(`Error processing section "${sectionTitle}":`, error);
                 // Display error within the section's content area
                 contentDiv.innerHTML = `<p style="color: red;">Error displaying this section.</p><pre style="white-space: pre-wrap; font-size: 0.8em;">${content.trim()}</pre>`;
                 sectionElement.style.display = 'block'; // Ensure section is visible even if content failed
            }
        }


        // --- Color Swatch Creation ---
        function createColorSwatches(container, text) {
            if (!container) {
                console.error("createColorSwatches called with null container.");
                return;
            }
            container.innerHTML = ''; // Clear only this specific container
            // Regex: Capture name (words, spaces, hyphens, slashes) followed by (#HEX)
            // Made slightly more robust: allows optional commas/spaces between colors
            const colorRegex = /([\w\s\-\/]+?)\s*\(\s*(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})\s*\)/g;
            let match;
            let foundColors = false;
            console.log("Attempting to parse colors from text:\n---\n", text, "\n---");

            while ((match = colorRegex.exec(text)) !== null) {
               foundColors = true;
               // Clean name: trim whitespace, remove trailing hyphens/spaces/commas
               const colorName = match[1].trim().replace(/[\s,-]+$/, '');
               let hexCode = match[2].trim().toUpperCase();

               // Expand 3-digit hex
               if (hexCode.length === 4) {
                   hexCode = '#' + hexCode[1] + hexCode[1] + hexCode[2] + hexCode[2] + hexCode[3] + hexCode[3];
               }

               // Validate hex length
               if (hexCode.length !== 7) {
                   console.warn(`Skipping invalid hex code format found: ${match[2]} for name ${colorName}`);
                   continue; // Skip this iteration
               }

               console.log(`   -> Found color: Name='${colorName}', Hex='${hexCode}'`);

               const swatch = document.createElement('div');
               swatch.className = 'color-swatch';
               try {
                   swatch.style.backgroundColor = hexCode;
                   // Set text color based on perceived lightness
                   swatch.style.color = isColorDarkGuess(hexCode) ? '#FFFFFF' : '#333333';
               } catch (e) {
                   // Handle cases where browser might reject a technically valid hex (rare)
                   console.error(`Browser rejected CSS color value ${hexCode}. Setting default background.`, e);
                   swatch.style.backgroundColor = '#CCCCCC'; // Fallback grey
                   swatch.style.color = '#000000';
               }

               const nameSpan = document.createElement('span');
               nameSpan.textContent = colorName;
               const hexSpan = document.createElement('span');
               hexSpan.className = 'hex-code';
               hexSpan.textContent = hexCode;

               swatch.appendChild(nameSpan);
               swatch.appendChild(hexSpan);
               container.appendChild(swatch);
            }

            if (!foundColors) {
                console.warn("Could not parse any colors using the regex from the provided text.");
                container.innerHTML = `<p style="font-style: italic; color: #6c757d;">Could not parse colors in 'Name (#XXXXXX)' format from the AI response.</p>`;
            } else {
                console.log(`Successfully created ${container.children.length} color swatches.`);
            }
        }


        // --- Color Lightness Guess ---
        function isColorDarkGuess(hexColor) {
            if (!hexColor || typeof hexColor !== 'string' || !hexColor.startsWith('#')) return false; // Basic validation
            try {
                let hex = hexColor.substring(1);
                if (hex.length === 3) {
                    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
                }
                if (hex.length !== 6) return false; // Invalid length after potential expansion

                const r = parseInt(hex.substring(0, 2), 16);
                const g = parseInt(hex.substring(2, 4), 16);
                const b = parseInt(hex.substring(4, 6), 16);

                // Calculate luminance (standard formula)
                const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255;
                return luminance < 0.5; // Threshold for "dark" (adjust if needed)
            } catch (e) {
                console.error("Error parsing hex color for lightness:", hexColor, e);
                return false; // Default to not dark on error
            }
        }

        // --- Utility Functions ---
        function clearResultsAndErrors() {
            const resultSections = resultsArea.querySelectorAll('.result-section');
            resultSections.forEach(section => {
                section.style.display = 'none'; // Hide the whole section
                const contentDiv = section.querySelector('.content');
                if (contentDiv) {
                    // Clear specific containers *within* the content div first
                    const imgContainerVisuals = section.querySelector('#result-visuals .image-placeholder-container');
                    if(imgContainerVisuals) imgContainerVisuals.innerHTML = '';

                    const moodboardDesc = section.querySelector('#moodboard-description');
                    if(moodboardDesc) moodboardDesc.textContent = '';
                    const moodboardImages = section.querySelector('#moodboard-images');
                    if(moodboardImages) moodboardImages.innerHTML = '';

                    const paletteContainer = section.querySelector('.color-palette-display');
                    if(paletteContainer) paletteContainer.innerHTML = '';

                    const requirementsList = section.querySelector('#result-requirements ul');
                    if(requirementsList) requirementsList.innerHTML = '';

                    const budgetContainer = section.querySelector('.budget-columns-container');
                    if(budgetContainer) budgetContainer.innerHTML = '';

                    // Clear any remaining general content (like the paragraph in Concept)
                    const conceptP = section.querySelector('#result-concept p');
                     if(conceptP) conceptP.innerHTML = '';

                    // As a final catch-all for sections not specifically handled above,
                    // clear the main contentDiv, but this is less ideal.
                    // contentDiv.innerHTML = ''; // Avoid this if possible, use specific selectors above
                }
            });
            resultsArea.style.display = 'none'; // Hide the main results area
            errorMessageDiv.style.display = 'none'; // Hide error message
            errorMessageDiv.textContent = '';
            console.log("Cleared previous results and errors.");
        }


        function displayError(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
            resultsArea.style.display = 'none'; // Hide results on error
            loadingIndicator.style.display = 'none'; // Hide loading indicator
            console.error("Displayed user error message:", message);
        }


        // --- Parallax Effect for Hero Image ---
        let isParallaxEnabled = true;

        function handleScrollParallax() {
             // Only apply if parallax is enabled, hero image exists, AND home page is active
            if (!heroImage || !isParallaxEnabled || !document.getElementById('home-page').classList.contains('active')) {
                 if (heroImage) { // Reset transform if not applicable
                     window.requestAnimationFrame(() => { heroImage.style.transform = 'scale(1.1) translateY(0px)'; });
                 }
                 return;
             }

            const scrollY = window.scrollY;
            // Slower parallax effect
            const translateY = scrollY * 0.25; // Adjusted multiplier

            window.requestAnimationFrame(() => {
                heroImage.style.transform = `scale(1.1) translateY(${translateY}px)`;
            });
        }

        function checkParallaxStatus() {
            if (window.innerWidth < 768) { // Disable on smaller screens
                isParallaxEnabled = false;
                 if(heroImage) { // Reset transform immediately if disabled
                     heroImage.style.transform = 'scale(1.1) translateY(0px)';
                 }
            } else {
                isParallaxEnabled = true;
                 // Re-apply parallax immediately if enabled and home page is active
                 handleScrollParallax();
            }
        }

        // --- Event Listeners Setup --- //
        // Page Navigation
        navLinks.forEach(link => { link.addEventListener('click', (e) => { e.preventDefault(); showPage(link.getAttribute('data-page')); }); });
        if (exploreButton) { exploreButton.addEventListener('click', () => showPage('feature')); }
        backButtons.forEach(button => { button.addEventListener('click', (e) => { e.preventDefault(); showPage('home'); }); });

        // Get Suggestions Button
        if (getSuggestionsButton) {
            getSuggestionsButton.addEventListener('click', handleGetSuggestions);
        } else {
            console.error("FATAL: Get Suggestions button element not found!");
        }

        // Parallax Listeners
        checkParallaxStatus(); // Initial check
        window.addEventListener('scroll', handleScrollParallax, { passive: true }); // Performance optimization
        window.addEventListener('resize', checkParallaxStatus);


        // --- Initial Setup ---
        showPage('home'); // Show the initial page
        console.log("MV Assistant Initialized.");

    }); // End DOMContentLoaded
</script>

</body>
</html>
