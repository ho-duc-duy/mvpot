<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be updated by JS -->
    <title
        data-lang-en="MV Concept Generator"
        data-lang-es="Generador de Conceptos MV"
        data-lang-vi="Trình tạo ý tưởng MV"
        data-lang-ja="MVコンセプトジェネレーター"
        data-lang-zhcn="MV概念生成器"
    >MV Concept Generator</title>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- NEW DESIGN SYSTEM --- */

        /* CSS Variables for Theme */
        :root {
            --bg-dark: #1a1a1d; /* Very dark grey, almost black */
            --bg-card: #2c2c30; /* Slightly lighter card background */
            --bg-card-hover: #35353a;
            --text-primary: #f0f0f5; /* Off-white */
            --text-secondary: #a9a9b3; /* Lighter grey */
            --accent-primary: #6a8ee7; /* Soft blue */
            --accent-secondary: #e476e4; /* Soft magenta/purple */
            --accent-gradient: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            --border-color: #404045;
            --success-color: #57cc99;
            --warning-color: #ffb703;
            --error-color: #e63946;
            --font-family: 'Poppins', sans-serif;
            --nav-height: 70px;
            --border-radius-sm: 6px;
            --border-radius-md: 10px;
            --box-shadow-soft: 0 4px 15px rgba(0, 0, 0, 0.2);
            --box-shadow-glow: 0 0 15px rgba(106, 142, 231, 0.3); /* Glow for accent elements */
        }

        /* Basic Reset & Defaults */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }
        body {
            font-family: var(--font-family);
            line-height: 1.7;
            color: var(--text-primary);
            background-color: var(--bg-dark);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden;
            transition: background-color 0.3s ease;
        }
        main {
            flex-grow: 1;
            padding-top: calc(var(--nav-height) + 2rem);
            padding-bottom: 4rem;
            width: 100%;
        }

        /* --- LOADING OVERLAY --- */
        #loading-overlay {
            position: fixed; inset: 0;
            background-color: rgba(26, 26, 29, 0.85);
            backdrop-filter: blur(5px);
            display: none; justify-content: center; align-items: center;
            z-index: 9999; flex-direction: column;
            opacity: 0; transition: opacity 0.4s ease-in-out;
        }
        #loading-overlay.show { display: flex; opacity: 1; }
        #loading-overlay p {
            font-weight: 500; color: var(--text-primary);
            margin-bottom: 20px; font-size: 1.2em;
            text-align: center; max-width: 80%;
        }
        .loading-spinner {
            width: 55px; height: 55px; border-radius: 50%;
            display: inline-block; position: relative; border: 4px solid;
            border-color: var(--accent-primary) var(--accent-primary) transparent transparent;
            animation: spin 1.2s linear infinite;
        }
        .loading-spinner::before, .loading-spinner::after {
            content: ''; position: absolute; left: 0; right: 0; bottom: 0; top: 0;
            border-radius: 50%; border: 4px solid transparent;
        }
        .loading-spinner::before { border-top-color: var(--accent-secondary); animation: spin 1.5s linear infinite; }
        .loading-spinner::after { border-left-color: rgba(240, 240, 245, 0.5); animation: spin 0.7s linear infinite; animation-direction: reverse; }
        @keyframes spin { to { transform: rotate(360deg); } }

        /* --- Navigation --- */
        .main-nav {
            background-color: rgba(44, 44, 48, 0.8); backdrop-filter: blur(10px);
            color: var(--text-primary); position: fixed; top: 0; left: 0; width: 100%;
            z-index: 1000; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex;
            justify-content: space-between; align-items: center; padding: 0 2rem; height: var(--nav-height);
        }
        .logo {
            font-weight: 600; font-size: 1.4rem; color: var(--text-primary); text-decoration: none;
            user-select: none; display: flex; align-items: center; gap: 0.5rem;
        }
        .logo img { max-height: 40px; width: auto; object-fit: contain; vertical-align: middle; }
        .main-nav ul { list-style: none; display: flex; align-items: center; gap: 1.5rem; }
        .main-nav ul li a {
            color: var(--text-secondary); text-decoration: none; padding: 0.5rem 0.8rem;
            font-size: 1rem; font-weight: 500; border-radius: var(--border-radius-sm);
            transition: color 0.3s ease, background-color 0.3s ease; position: relative; overflow: hidden; cursor: pointer;
        }
        .main-nav ul li a::after {
            content: ''; position: absolute; bottom: 0; left: 0; width: 100%; height: 2px;
            background: var(--accent-gradient); transform: scaleX(0); transform-origin: right;
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .main-nav ul li a:hover, .main-nav ul li a.active { color: var(--text-primary); background-color: rgba(255, 255, 255, 0.05); }
        .main-nav ul li a.active::after { transform: scaleX(1); transform-origin: left; }

        /* --- Settings Box (Language) --- */
        #settings-box { display: flex; align-items: center; gap: 0.6rem; }
        #settings-box label { font-size: 0.9rem; color: var(--text-secondary); }
        #settings-box select {
            padding: 0.4rem 0.6rem; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color);
            background-color: var(--bg-card); color: var(--text-primary); font-size: 0.9rem; cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        #settings-box select:focus { outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 2px rgba(106, 142, 231, 0.3); }

        /* --- General Content & Pages --- */
        .container { max-width: 1100px; margin: 0 auto; padding: 0 1.5rem; }
        .page { display: none; animation: sectionFadeIn 0.8s ease-out forwards; min-height: calc(100vh - var(--nav-height) - 6rem); }
        .page.active { display: block; }
        @keyframes sectionFadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Home Page --- */
        #home-page { text-align: center; padding-top: 3rem; }
        .hero-section {
            padding: 4rem 1rem; border-radius: var(--border-radius-md); background: rgba(44, 44, 48, 0.5);
            margin-bottom: 3rem; position: relative; overflow: hidden;
        }
        .hero-section::before {
            content: ''; position: absolute; inset: 0; z-index: 0; opacity: 0.7;
            background: radial-gradient(circle at top left, rgba(106, 142, 231, 0.1), transparent 60%),
                        radial-gradient(circle at bottom right, rgba(228, 118, 228, 0.1), transparent 60%);
            animation: pulseGlow 10s infinite alternate ease-in-out;
        }
        @keyframes pulseGlow { from { opacity: 0.5; transform: scale(1); } to { opacity: 1; transform: scale(1.05); } }
        .hero-content { position: relative; z-index: 1; }
        .hero-section h1 {
            font-size: clamp(2rem, 5vw, 3.2rem); font-weight: 700; margin-bottom: 1.5rem; color: var(--text-primary);
            line-height: 1.3; animation: textFadeUp 1s 0.2s ease-out forwards; opacity: 0;
        }
        @keyframes textFadeUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .hero-section .tagline {
            font-size: 1.1rem; color: var(--text-secondary); margin-bottom: 2.5rem; max-width: 650px; margin-left: auto; margin-right: auto;
            animation: textFadeUp 1s 0.4s ease-out forwards; opacity: 0;
        }
        .hero-section .btn { animation: buttonScaleIn 0.8s 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; opacity: 0; transform: scale(0.8); }
        @keyframes buttonScaleIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }

        /* --- About Page --- */
        #about-page .content-container {
            max-width: 850px; margin: 2rem auto; padding: 2.5rem; background-color: var(--bg-card);
            border-radius: var(--border-radius-md); box-shadow: var(--box-shadow-soft);
        }
        #about-page h2 {
            font-size: 2rem; font-weight: 600; margin-bottom: 1.5rem; color: var(--accent-primary);
            text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 0.8rem;
        }
        #about-page p { font-size: 1.05rem; color: var(--text-secondary); text-align: justify; line-height: 1.8; }
        #about-page .btn-back { display: block; width: fit-content; margin: 2rem auto 0 auto; }

        /* --- Feature Page (Input & Results) --- */
        .input-section, .results-section { margin-bottom: 3rem; }
        .form-container {
            background-color: var(--bg-card); padding: 2.5rem; border-radius: var(--border-radius-md);
            box-shadow: var(--box-shadow-soft); max-width: 900px; margin: 0 auto;
        }
        .form-container h1 {
            font-size: 2.2rem; font-weight: 600; text-align: center; margin-bottom: 2rem;
            background: var(--accent-gradient); -webkit-background-clip: text; background-clip: text; color: transparent;
        }
        .form-group { margin-bottom: 1.8rem; }
        .form-group label { display: block; margin-bottom: 0.7rem; font-weight: 500; color: var(--text-secondary); font-size: 1rem; }
        .form-group input[type="text"], .form-group textarea, .form-group select {
            width: 100%; padding: 0.9rem 1rem; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm);
            font-size: 1rem; background-color: var(--bg-dark); color: var(--text-primary);
            transition: border-color 0.3s ease, box-shadow 0.3s ease; font-family: inherit;
        }
        .form-group input[type="text"]:focus, .form-group textarea:focus, .form-group select:focus {
             outline: none; border-color: var(--accent-primary); box-shadow: 0 0 0 3px rgba(106, 142, 231, 0.2);
        }
        .form-group textarea { resize: vertical; min-height: 140px; }
        .form-group select {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23a9a9b3" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat; background-position: right 1rem center; background-size: 20px; padding-right: 3rem; cursor: pointer;
        }
        .form-group select option[disabled] { color: #777; }
        .audio-input-group { display: flex; align-items: center; flex-wrap: wrap; gap: 1rem; }
        .form-group input[type="file"] {
             padding: 0; cursor: pointer; flex-grow: 1; min-width: 200px; margin-bottom: 0;
             background-color: transparent; border: none; box-shadow: none; color: var(--text-secondary);
        }
        input[type="file"]::file-selector-button {
             padding: 0.7rem 1.2rem; margin-right: 1rem; border: none; border-radius: var(--border-radius-sm);
             background: linear-gradient(135deg, #444, #555); color: var(--text-primary);
             cursor: pointer; transition: background 0.3s ease, transform 0.1s ease; font-weight: 500;
        }
        input[type="file"]::file-selector-button:hover { background: linear-gradient(135deg, #555, #666); transform: translateY(-1px); }
        #record-status { margin-left: 1rem; font-style: italic; font-weight: 500; display: inline-flex; align-items: center; min-height: 24px; transition: color 0.3s ease; }
        #record-status.recording { color: var(--error-color); }
        #record-status.transcribing { color: var(--accent-primary); }
        #record-status.complete { color: var(--success-color); }
        #record-status.error { color: var(--error-color); }
        .recording-dots { display: inline-block; vertical-align: middle; margin-right: 6px; }
        .recording-dots span {
            display: inline-block; width: 9px; height: 9px; margin-left: 4px; border-radius: 50%; background-color: var(--error-color);
            animation: recordingPulse 1.4s infinite ease-in-out;
        }
        .recording-dots span:nth-child(1) { animation-delay: 0s; }
        .recording-dots span:nth-child(2) { animation-delay: 0.2s; }
        .recording-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes recordingPulse { 0%, 100% { transform: scale(0.5); opacity: 0.5; } 50% { transform: scale(1); opacity: 1; } }
        #transcript-group { display: none; margin-top: 1.5rem; }
        #transcript-output { background-color: #333; font-style: italic; color: var(--text-secondary); min-height: 90px; cursor: default; border-color: #444; }
        .form-group small { display: block; margin-top: 0.8rem; color: var(--text-secondary); font-size: 0.9em; line-height: 1.5; }
        #generate-concept-button { display: block; width: 100%; max-width: 380px; margin: 2.5rem auto 0 auto; padding: 1rem 1.5rem; font-size: 1.1rem; }

        /* --- Results Section & Cards --- */
        .results-section { display: none; margin-top: 3rem; }
        .results-grid { display: grid; grid-template-columns: 1fr; gap: 1.8rem; } /* Single column layout */
        .result-card {
            background-color: var(--bg-card); border-radius: var(--border-radius-md); padding: 1.8rem;
            box-shadow: var(--box-shadow-soft); border: 1px solid var(--border-color);
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            opacity: 0; transform: translateY(30px); display: flex; flex-direction: column;
        }
        .result-card.visible { opacity: 1; transform: translateY(0); transition: opacity 0.6s ease-out, transform 0.6s ease-out; /* delay set by JS */ }
        .result-card:hover { transform: translateY(-5px); box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3); border-color: var(--accent-primary); }
        .result-card h2 {
            font-size: 1.5rem; font-weight: 600; color: var(--accent-primary); margin-bottom: 1.2rem;
            padding-bottom: 0.6rem; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 0.5rem; flex-shrink: 0;
        }
        .card-content { font-size: 0.95rem; color: var(--text-secondary); line-height: 1.7; flex-grow: 1; overflow: hidden; }
        .card-content p { margin-bottom: 1rem; }
        .card-content p:last-child { margin-bottom: 0; }
        .card-content strong { color: var(--text-primary); font-weight: 600; }
        #result-concept > .card-content { white-space: pre-wrap; } /* Concept text wrapping */

        /* Requirements List */
        #result-requirements ul { margin: 0.5rem 0 0 0; padding-left: 0; list-style: none; }
        #result-requirements li { margin-bottom: 0.8rem; padding-left: 1.8rem; position: relative; }
        #result-requirements li::before {
            content: '✓'; color: var(--accent-primary); font-size: 1.1em; font-weight: 600;
            position: absolute; left: 0; top: 1px; transition: transform 0.3s ease;
        }
        #result-requirements li:hover::before { transform: scale(1.2) rotate(-10deg); }

        /* MODIFIED: Budget Section Styles */
        .budget-columns-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Ensure 3 columns */
            gap: 1.2rem;
            margin-top: 1rem;
        }
        .budget-column {
            border: 1px solid var(--border-color);
            padding: 1.2rem;
            border-radius: var(--border-radius-sm);
            background-color: rgba(26, 26, 29, 0.7);
            display: flex; flex-direction: column; /* Stack elements vertically */
            transition: background-color 0.3s ease;
            min-height: 180px; /* Ensure columns have some base height */
        }
        .budget-column:hover { background-color: rgba(40, 40, 43, 0.8); }
        .budget-column h3 {
            margin-top: 0; margin-bottom: 1rem; padding-bottom: 0.5rem;
            border-bottom: 1px solid #555; color: var(--text-primary);
            font-size: 1.1rem; font-weight: 600; flex-shrink: 0; /* Prevent shrinking */
            text-align: center;
        }
        .budget-column p { /* Holds the main description and item boxes */
            font-size: 0.95rem; /* Matches .card-content */
            line-height: 1.7;    /* Matches .card-content */
            color: var(--text-secondary);
            white-space: normal; /* Allow wrapping */
            margin-bottom: 0;
            flex-grow: 1; /* Allow description to take space */
        }
        /* Style for individual cost items within the description */
        .budget-column .budget-item-box {
             border: 1px solid #555;
             background-color: var(--bg-dark);
             padding: 0.6rem 0.8rem;
             margin-top: 0.8rem; /* Space above item */
             margin-bottom: 0.6rem; /* Space below item */
             border-radius: 4px;
             font-size: 0.85em; /* Relative to parent p */
             box-shadow: 0 1px 2px rgba(0,0,0,0.1);
             display: flex; /* Put item name and cost side-by-side */
             justify-content: space-between;
             align-items: center;
        }
        .budget-column .budget-item-box strong { /* Style the cost part */
            color: var(--text-primary);
            margin-left: 0.5rem; /* Space between item and cost */
            white-space: nowrap; /* Prevent cost from wrapping */
            font-weight: 600;
        }
        /* Placeholder styling specifically for budget columns */
        .budget-column.placeholder-notice {
            border-style: dashed;
            opacity: 0.7;
        }
        .budget-column.placeholder-notice h3 {
            color: var(--text-secondary);
            border-bottom-color: rgba(85, 85, 85, 0.5);
        }
        .budget-column.placeholder-notice p.placeholder-notice { /* Style placeholder text inside budget P */
            text-align: center;
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 1rem;
            font-size: 0.95rem; /* Ensure placeholder text also matches */
            line-height: 1.7;
        }
        /* Main container placeholder */
        .budget-columns-container.placeholder-notice {
            display: block; /* Override grid for single placeholder text */
            text-align: center;
            padding: 1rem;
        }
        .budget-columns-container.placeholder-notice .budget-column {
            display: none; /* Hide columns when main container has placeholder */
        }
        /* --- Style for raw text display on parsing error (MODIFIED) --- */
        .card-content .raw-budget-output pre { /* Target pre inside raw-budget-output class */
            white-space: pre-wrap;
            font-family: monospace;
            font-size: 1.2em;
            text-align: left;
            background-color: rgba(0,0,0,0.3); /* Slightly darker background */
            border: 1px dashed var(--border-color); /* Dashed border */
            color: var(--text-secondary);
            padding: 1rem;
            border-radius: var(--border-radius-sm);
            margin-top: 0.5rem;
            max-height: 200px; /* Increased max-height */
            overflow-y: auto;
        }


        /* Image Placeholder (Inside Card) */
        .image-placeholder-container { display: grid; gap: 1.2rem; margin-top: 1rem; }
        #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
        #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); }
        .image-placeholder {
            border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); background-color: var(--bg-dark);
            overflow: hidden; text-align: center; color: var(--text-secondary); box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease; position: relative;
        }
        .image-placeholder:hover { transform: scale(1.03); box-shadow: 0 5px 12px rgba(0,0,0,0.3); z-index: 5; }
        .image-placeholder img {
            display: block; width: 100%; object-fit: cover; background-color: #444; border-bottom: 1px solid var(--border-color);
            opacity: 0; transition: opacity 0.5s ease-in-out;
        }
        .image-placeholder img[src]:not([src=""]) { opacity: 1; }
        #result-visuals .image-placeholder img { height: 160px; }
        #result-moodboard .image-placeholder img { height: 130px; }
        .image-placeholder figcaption {
            font-size: 0.85em; padding: 0.8rem; background-color: var(--bg-card);
            min-height: 55px; line-height: 1.4; color: var(--text-secondary);
        }
        .image-placeholder figcaption strong { color: var(--text-primary); }
        .image-placeholder figcaption .generation-source { /* New style for Replicate note */
            font-size: 0.8em; display: block; margin-top: 5px; color: var(--accent-primary);
        }
        .image-placeholder figcaption .fallback-notice { font-size: 0.8em; display: block; margin-top: 4px; color: #888; font-style: italic; }

        /* Color Palette Display (Inside Card) */
        .color-palette-display { display: flex; flex-wrap: wrap; gap: 1rem; margin-top: 1rem; }
        .color-swatch {
            min-width: 100px; height: 90px; border-radius: var(--border-radius-sm); border: 1px solid var(--border-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.85em;
            font-weight: 500; text-align: center; overflow: hidden; padding: 0.5rem; box-shadow: 0 1px 4px rgba(0,0,0,0.15);
            transition: transform 0.25s ease, box-shadow 0.25s ease; flex-grow: 1; opacity: 0; transform: scale(0.8);
        }
        .color-swatch.visible { opacity: 1; transform: scale(1); transition: opacity 0.4s ease-out, transform 0.4s ease-out; /* delay handled by JS */ }
        .color-swatch:hover { transform: scale(1.08) rotate(2deg); box-shadow: 0 4px 10px rgba(0,0,0,0.25); z-index: 5; }
        .color-swatch span { display: block; word-break: break-word; max-width: 100%; }
        .color-swatch .hex-code { margin-top: 0.5rem; font-size: 0.9em; font-family: monospace; user-select: all; opacity: 0.8; }

        /* Action Buttons */
        .action-buttons {
            margin-top: 2rem; padding-top: 2rem; border-top: 1px solid var(--border-color);
            display: flex; justify-content: center; gap: 1.5rem; flex-wrap: wrap; flex-shrink: 0;
        }

        /* --- General Button Styling --- */
        .btn {
            display: inline-block; padding: 0.8rem 1.8rem; border: none; border-radius: var(--border-radius-sm);
            cursor: pointer; font-size: 1rem; font-weight: 600; text-align: center; text-decoration: none;
            color: var(--text-primary); background: var(--accent-gradient);
            transition: transform 0.2s ease, box-shadow 0.3s ease, background-size 0.4s ease, opacity 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); position: relative; overflow: hidden; z-index: 1;
        }
        .btn::before { /* Subtle shine effect on hover */
             content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
             background: linear-gradient(120deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.2) 50%, rgba(255,255,255,0) 100%);
             transition: left 0.5s ease; z-index: -1;
        }
        .btn:hover:not(:disabled) { transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 15px rgba(106, 142, 231, 0.3); }
        .btn:hover:not(:disabled)::before { left: 100%; }
        .btn:active:not(:disabled) { transform: translateY(0) scale(0.98); box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; background: #555; box-shadow: none; }
        .btn-secondary { background: linear-gradient(135deg, #5a5a60, #404045); }
        .btn-secondary:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(80, 80, 80, 0.3); }
        .btn-warning { background: linear-gradient(135deg, var(--warning-color), #d4a00e); color: #222; }
        .btn-warning:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(255, 183, 3, 0.4); color: #000; }
        .btn-danger { background: linear-gradient(135deg, var(--error-color), #b82c3a); }
        .btn-danger:hover:not(:disabled) { box-shadow: 0 5px 15px rgba(230, 57, 70, 0.4); }
        #home-page .btn-back { display: none; } /* Hide back button on home */

        /* --- Error Message --- */
        .error-message {
            background-color: rgba(230, 57, 70, 0.15); color: var(--error-color); border: 1px solid rgba(230, 57, 70, 0.5);
            padding: 1.2rem 1.5rem; border-radius: var(--border-radius-sm); margin: 1.5rem auto; text-align: center;
            font-weight: 500; display: none; max-width: 800px; white-space: pre-wrap;
        }
        /* Specific styling for error paragraphs inside card content */
        .card-content p.error {
            color: var(--error-color);
            font-weight: 500;
        }


        /* --- Footer --- */
        .main-footer {
            background-color: #111; color: var(--text-secondary); padding: 1.5rem 0;
            text-align: center; font-size: 0.9rem; margin-top: auto;
        }
        .main-footer p { margin: 0; }
        .main-footer a { color: var(--accent-primary); text-decoration: none; transition: color 0.3s ease; }
        .main-footer a:hover { color: var(--accent-secondary); }

        /* --- Utility Placeholders --- */
        .placeholder-notice {
            font-style: italic; color: var(--text-secondary); opacity: 0.8;
            text-align: center; padding: 1rem; font-size: 0.9em;
        }
        #result-requirements ul .placeholder-notice { padding: 0; text-align: left; list-style: none; margin-left: 1.8rem; }
        #result-requirements ul .placeholder-notice::before { display: none; }
        /* Ensure image/color placeholders inside cards look right */
        .image-placeholder-container.placeholder-notice,
        .color-palette-display.placeholder-notice {
            display: block; /* Override grid/flex for placeholder text */
            text-align: center; padding: 1rem;
        }
         /* Ensure budget note is always visible, even with placeholders */
         #result-budget > small { display: block; text-align: center; margin-top: 1rem; font-size: 0.85em; opacity: 0.8; }

        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
            .container { max-width: 90%; }
            .main-nav ul { gap: 1rem; }
            .main-nav ul li a { font-size: 0.95rem; padding: 0.4rem 0.6rem; }
            #settings-box label { display: none; }
            .form-container { padding: 2rem; }
        }

        @media (max-width: 768px) {
            html { font-size: 15px; }
            :root { --nav-height: 60px; }
            main { padding-top: calc(var(--nav-height) + 1.5rem); }
            .main-nav { padding: 0 1.5rem; flex-wrap: wrap; height: auto; min-height: var(--nav-height); align-content: center; }
            .logo { font-size: 1.2rem; }
            .main-nav ul { order: 3; width: 100%; justify-content: center; padding: 0.5rem 0; border-top: 1px solid var(--border-color); margin-top: 0.5rem; gap: 0.8rem; }
            #settings-box { order: 2; margin-left: auto; padding-bottom: 0.5rem; }
            .hero-section { padding: 3rem 0.5rem; }
            .hero-section h1 { font-size: clamp(1.8rem, 6vw, 2.5rem); }
            .hero-section .tagline { font-size: 1rem; }
            /* Stack budget columns on smaller screens */
            .budget-columns-container { grid-template-columns: 1fr; gap: 1rem; }
            .budget-column { min-height: auto; } /* Let height adjust */
            .result-card { padding: 1.5rem; }
            .result-card h2 { font-size: 1.4rem; }
            #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); }
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            #about-page .content-container { padding: 1.5rem; }
        }

        @media (max-width: 480px) {
            html { font-size: 14px; }
            .main-nav { padding: 0 1rem; }
            .main-nav ul { gap: 0.5rem; flex-wrap: wrap; justify-content: space-around; }
            .main-nav ul li a { padding: 0.4rem; font-size: 0.9rem; }
            #settings-box { width: 100%; order: 3; justify-content: center; margin-left: 0; margin-top: 0.5rem; padding-bottom: 0.5rem; }
            .container { padding: 0 1rem; }
            .form-container { padding: 1.5rem; }
            .form-container h1 { font-size: 1.8rem; margin-bottom: 1.5rem; }
            .form-group { margin-bottom: 1.5rem; }
            .audio-input-group { flex-direction: column; align-items: stretch; gap: 0.8rem; }
            input[type="file"]::file-selector-button { width: 100%; text-align: center; margin-right: 0; }
            .audio-input-group .btn { width: 100%; margin: 0;}
            #record-status { margin-left: 0; justify-content: center; width: 100%; margin-top: 0.3rem; }
            #generate-concept-button { max-width: 100%; padding: 0.9rem 1.2rem; font-size: 1rem; }
            .btn { padding: 0.7rem 1.5rem; font-size: 0.95rem; }
            .action-buttons { gap: 1rem; }
            #result-visuals .image-placeholder-container,
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); }
            #result-visuals .image-placeholder img { height: 130px; }
            #result-moodboard .image-placeholder img { height: 110px; }
            .color-palette-display { gap: 0.8rem; }
            .color-swatch { min-width: 80px; height: 70px; font-size: 0.8rem; }
        }

    </style>
</head>
<body>

    <!-- Loading Overlay Div -->
    <div id="loading-overlay">
        <div class="loading-spinner"></div>
        <p
            data-lang-en="Generating creative sparks..."
            data-lang-es="Generando chispas creativas..."
            data-lang-vi="Đang tạo ra những tia sáng sáng tạo..."
            data-lang-ja="創造的な火花を生成中..."
            data-lang-zhcn="正在生成创意火花..."
            data-last-key="generatingCreativeSparks"
        >Generating creative sparks...</p>
    </div>

    <!-- Navigation -->
    <nav class="main-nav">
        <a href="#" data-page="home" class="logo nav-link">
             <!-- Assume logofinal(white).png exists or replace -->
             <img src="logofinal(white).png" alt="MV Generator Logo" style="max-height: 40px; width: auto; vertical-align: middle; border-radius: 3px;" onerror="this.style.display='none'; this.nextElementSibling.style.display='inline';">
             <span style="display: none;"
                data-lang-en="Logo"
                data-lang-es="Logo"
                data-lang-vi="Logo"
                data-lang-ja="ロゴ"
                data-lang-zhcn="标志"
             >Logo</span> <!-- Fallback Text -->
        </a>
        <ul>
            <li><a data-page="home" class="nav-link active"
                   data-lang-en="Home" data-lang-es="Inicio" data-lang-vi="Trang chủ" data-lang-ja="ホーム" data-lang-zhcn="首页"
                >Home</a></li>
            <li><a data-page="about" class="nav-link"
                   data-lang-en="About" data-lang-es="Acerca de" data-lang-vi="Giới thiệu" data-lang-ja="概要" data-lang-zhcn="关于"
                >About</a></li>
            <li><a data-page="feature" class="nav-link"
                   data-lang-en="Generate" data-lang-es="Generar" data-lang-vi="Tạo" data-lang-ja="生成" data-lang-zhcn="生成"
                >Generate</a></li>
        </ul>
        <!-- Settings Box for Language -->
        <div id="settings-box">
            <label for="language-select"
                data-lang-en="Language:" data-lang-es="Idioma:" data-lang-vi="Ngôn ngữ:" data-lang-ja="言語：" data-lang-zhcn="语言："
            >Language:</label>
            <select id="language-select">
                <option value="en">English</option>
                <option value="es">Español</option>
                <option value="vi">Tiếng Việt</option>
                <option value="ja">日本語</option>
                <option value="zh-CN">中文</option>
            </select>
        </div>
    </nav>

    <main>
        <!-- Home Page Section -->
        <section id="home-page" class="page active container">
            <div class="hero-section">
                <div class="hero-content">
                    <h1
                        data-lang-en="Unlock Visual Concepts for Your Music" data-lang-es="Desbloquea Conceptos Visuales para Tu Música" data-lang-vi="Mở khóa ý tưởng hình ảnh cho âm nhạc của bạn" data-lang-ja="あなたの音楽のためのビジュアルコンセプトを解き放つ" data-lang-zhcn="为您的音乐解锁视觉概念"
                    >Unlock Visual Concepts for Your Music</h1>
                    <p class="tagline"
                       data-lang-en="Transform your lyrics and ideas into stunning music video concepts with the power of AI." data-lang-es="Transforma tus letras e ideas en impresionantes conceptos de videos musicales con el poder de la IA." data-lang-vi="Biến lời bài hát và ý tưởng của bạn thành những ý tưởng video âm nhạc tuyệt đẹp với sức mạnh của AI." data-lang-ja="AIの力で、あなたの歌詞やアイデアを見事なミュージックビデオコンセプトに変えましょう。" data-lang-zhcn="借助人工智能的力量，将您的歌词和想法转化为令人惊叹的音乐视频概念。"
                    >Transform your lyrics and ideas into stunning music video concepts with the power of AI.</p>
                    <button id="explore-button" class="btn btn-primary"
                            data-lang-en="Start Generating" data-lang-es="Comenzar a Generar" data-lang-vi="Bắt đầu tạo" data-lang-ja="生成を開始" data-lang-zhcn="开始生成"
                        >Start Generating</button>
                </div>
            </div>
        </section>

        <!-- About Page Section -->
        <section id="about-page" class="page container">
            <div class="content-container">
                <h2
                    data-lang-en="About MV Generator" data-lang-es="Acerca del Generador MV" data-lang-vi="Về Trình tạo MV" data-lang-ja="MVジェネレーターについて" data-lang-zhcn="关于 MV 生成器"
                >About MV Generator</h2>
                <p
                   data-lang-en="Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, and genre, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, and color palettes. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!"
                   data-lang-es="¡Bienvenido al Generador de MV! Nos apasiona ayudar a los artistas a traducir sus creaciones musicales en historias visuales convincentes. Crear el concepto perfecto para un video musical puede ser desafiante, requiriendo una mezcla de visión artística y planificación práctica. Nuestra herramienta impulsada por IA está diseñada para cerrar esa brecha. Al analizar tus letras, palabras clave y género, el Generador de MV genera sugerencias personalizadas para conceptos de videos musicales, requisitos, estimaciones de presupuesto, inspiraciones visuales y paletas de colores. Nuestro objetivo es agilizar el proceso creativo, proporcionando una plataforma de lanzamiento para tus ideas y empoderándote para dar vida visual a tu música, ya seas un artista independiente o parte de una producción más grande. ¡Hagamos algo increíble juntos!"
                   data-lang-vi="Chào mừng bạn đến với Trình tạo MV! Chúng tôi đam mê giúp các nghệ sĩ chuyển đổi những sáng tạo âm nhạc của họ thành những câu chuyện hình ảnh hấp dẫn. Việc tạo ra ý tưởng video âm nhạc hoàn hảo có thể đầy thử thách, đòi hỏi sự kết hợp giữa tầm nhìn nghệ thuật và kế hoạch thực tế. Công cụ hỗ trợ AI của chúng tôi được thiết kế để thu hẹp khoảng cách đó. Bằng cách phân tích lời bài hát, từ khóa và thể loại của bạn, Trình tạo MV tạo ra các đề xuất phù hợp cho các khái niệm video âm nhạc, yêu cầu, ước tính ngân sách, nguồn cảm hứng trực quan và bảng màu. Chúng tôi mong muốn hợp lý hóa quy trình sáng tạo, cung cấp bệ phóng cho ý tưởng của bạn và trao quyền cho bạn để đưa âm nhạc của mình vào cuộc sống một cách trực quan, cho dù bạn là một nghệ sĩ độc lập hay là một phần của một nhà sản xuất lớn hơn. Hãy cùng nhau tạo ra điều gì đó tuyệt vời!"
                   data-lang-ja="MVジェネレーターへようこそ！私たちは、アーティストが音楽作品を魅力的なビジュアルストーリーに変換するお手伝いをすることに情熱を注いでいます。完璧なミュージックビデオのコンセプトを作り上げることは、芸術的なビジョンと実践的な計画の融合を必要とする、困難な作業となる場合があります。当社のAI搭載ツールは、そのギャップを埋めるために設計されています。あなたの歌詞、キーワード、ジャンルを分析することにより、MVジェネレーターはミュージックビデオのコンセプト、要件、予算の見積もり、視覚的なインスピレーション、カラーパレットに関するカスタマイズされた提案を生成します。私たちは、インディーズアーティストであろうと大規模なプロダクションの一部であろうと、あなたのアイデアの出発点を提供し、あなたの音楽を視覚的に実現する力を与えることで、創造的なプロセスを合理化することを目指しています。一緒に素晴らしいものを作りましょう！"
                   data-lang-zhcn="欢迎来到 MV 生成器！我们热衷于帮助艺术家将他们的音乐创作转化为引人入胜的视觉故事。制作完美的音乐视频概念可能具有挑战性，需要艺术视野和实际规划的结合。我们的人工智能工具旨在弥合这一差距。通过分析您的歌词、关键词和流派，MV 生成器会生成量身定制的音乐视频概念、要求、预算估算、视觉灵感和调色板建议。我们的目标是简化创作过程，为您的想法提供一个启动平台，并使您能够将音乐以视觉方式呈现出来，无论您是独立艺术家还是大型制作团队的一员。让我们一起创造一些惊人的东西吧！"
                >
                    Welcome to the MV Generator! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, and genre, MV Generator generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, and color palettes. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!
                </p>
                 <button class="btn btn-secondary btn-back" data-target="home"
                    data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页"
                >Back to Home</button>
            </div>
        </section>

        <!-- Feature Page Section (Input & Results) -->
        <section id="feature-page" class="page container">
            <!-- Input Form Area -->
            <div class="input-section">
                <div class="form-container">
                    <h1
                        data-lang-en="Generate Your MV Concept" data-lang-es="Genera Tu Concepto de MV" data-lang-vi="Tạo ý tưởng MV của bạn" data-lang-ja="MVコンセプトを生成" data-lang-zhcn="生成您的 MV 概念"
                    >Generate Your MV Concept</h1>

                    <form id="feature-form" onsubmit="return false;">
                        <div class="form-group">
                            <label for="lyrics-input"
                                data-lang-en="Music Lyrics:" data-lang-es="Letra de la Música:" data-lang-vi="Lời bài hát:" data-lang-ja="歌詞：" data-lang-zhcn="歌词："
                            >Music Lyrics:</label>
                            <textarea id="lyrics-input" rows="7" required
                                data-lang-en-placeholder="Paste your complete song lyrics here..." data-lang-es-placeholder="Pega la letra completa de tu canción aquí..." data-lang-vi-placeholder="Dán toàn bộ lời bài hát của bạn vào đây..." data-lang-ja-placeholder="ここに完全な歌詞を貼り付けてください..." data-lang-zhcn-placeholder="在此处粘贴完整的歌词..."
                                placeholder="Paste your complete song lyrics here..." ></textarea>
                        </div>
                        <div class="form-group">
                            <label for="keywords-input"
                                data-lang-en="Keywords / Theme:" data-lang-es="Palabras Clave / Tema:" data-lang-vi="Từ khóa / Chủ đề:" data-lang-ja="キーワード / テーマ：" data-lang-zhcn="关键词/主题："
                            >Keywords / Theme:</label>
                            <input type="text" id="keywords-input" required
                                data-lang-en-placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle" data-lang-es-placeholder="ej., nostálgico, ambiente de verano, decadencia urbana, superación" data-lang-vi-placeholder="vd: hoài cổ, không khí mùa hè, suy tàn đô thị, vượt qua khó khăn" data-lang-ja-placeholder="例：ノスタルジック、夏の雰囲気、都市の荒廃、苦難の克服" data-lang-zhcn-placeholder="例如，怀旧、夏日氛围、城市衰败、克服困难"
                                placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle" >
                        </div>
                        <div class="form-group">
                            <label for="genre-select"
                                data-lang-en="Music Genre:" data-lang-es="Género Musical:" data-lang-vi="Thể loại âm nhạc:" data-lang-ja="音楽ジャンル：" data-lang-zhcn="音乐流派："
                            >Music Genre:</label>
                            <select id="genre-select" required>
                                <option value="" disabled selected
                                    data-lang-en="-- Select a Genre --" data-lang-es="-- Selecciona un Género --" data-lang-vi="-- Chọn một thể loại --" data-lang-ja="-- ジャンルを選択 --" data-lang-zhcn="-- 选择流派 --"
                                >-- Select a Genre --</option>
                                <option value="RnB">RnB / Soul</option>
                                <option value="Folk">Folk / Acoustic</option>
                                <option value="Rock">Rock</option>
                                <option value="Pop">Pop</option>
                                <option value="Hiphop">Hip-hop / Rap</option>
                                <option value="Electronic">Electronic</option>
                                <option value="Classical">Classical</option>
                                <option value="Country">Country</option>
                                <option value="Jazz">Jazz / Blues</option>
                                <option value="Reggae">Reggae</option>
                                <option value="Metal">Metal</option>
                                <option value="Other">Other / Fusion</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="track-upload"
                                data-lang-en="Track Input (Optional):" data-lang-es="Entrada de Pista (Opcional):" data-lang-vi="Nhập bản nhạc (Tùy chọn):" data-lang-ja="トラック入力（任意）：" data-lang-zhcn="音轨输入（可选）："
                            >Track Input (Optional):</label>
                            <div class="audio-input-group">
                                <input type="file" id="track-upload" accept="audio/*">
                                <button type="button" id="record-audio-button" class="btn btn-warning"
                                    data-lang-en-record="Record Audio" data-lang-es-record="Grabar Audio" data-lang-vi-record="Ghi âm" data-lang-ja-record="音声を録音" data-lang-zhcn-record="录制音频"
                                    data-lang-en-stop="Stop Recording" data-lang-es-stop="Detener Grabación" data-lang-vi-stop="Dừng ghi âm" data-lang-ja-stop="録音停止" data-lang-zhcn-stop="停止录制"
                                >Record Audio</button>
                                <span id="record-status" class="record-status-base">
                                    <span id="recording-animation" class="recording-dots" style="display: none;"><span></span><span></span><span></span></span>
                                    <span id="record-status-text"></span>
                                </span>
                            </div>
                            <small
                                data-lang-en="Upload an audio file or record your singing. Analysis enhances suggestions (requires browser support)." data-lang-es="Sube un archivo de audio o graba tu canto. El análisis mejora las sugerencias (requiere soporte del navegador)." data-lang-vi="Tải lên tệp âm thanh hoặc ghi âm giọng hát của bạn. Phân tích giúp cải thiện đề xuất (yêu cầu trình duyệt hỗ trợ)." data-lang-ja="オーディオファイルをアップロードするか、歌声を録音します。分析により提案が強化されます（ブラウザのサポートが必要です）。" data-lang-zhcn="上传音频文件或录制您的演唱。分析可增强建议（需要浏览器支持）。"
                            >
                                Upload an audio file or record your singing. Analysis enhances suggestions (requires browser support).
                            </small>
                        </div>
                        <div class="form-group" id="transcript-group" style="display: none;">
                            <label for="transcript-output"
                                data-lang-en="Singing Transcript (from recording):" data-lang-es="Transcripción del Canto (de grabación):" data-lang-vi="Bản ghi lời hát (từ ghi âm):" data-lang-ja="歌唱トランスクリプト（録音より）：" data-lang-zhcn="演唱转录稿（来自录音）："
                            >Singing Transcript (from recording):</label>
                            <textarea id="transcript-output" rows="4" readonly
                                data-lang-en-placeholder="Transcript will appear here..." data-lang-es-placeholder="La transcripción aparecerá aquí..." data-lang-vi-placeholder="Bản ghi sẽ xuất hiện ở đây..." data-lang-ja-placeholder="トランスクリプトがここに表示されます..." data-lang-zhcn-placeholder="转录稿将显示在此处..."
                                placeholder="Transcript will appear here..."></textarea>
                            <small
                                data-lang-en="This text will be analyzed along with lyrics." data-lang-es="Este texto se analizará junto con la letra." data-lang-vi="Văn bản này sẽ được phân tích cùng với lời bài hát." data-lang-ja="このテキストは歌詞とともに分析されます。" data-lang-zhcn="此文本将与歌词一起分析。"
                            >This text will be analyzed along with lyrics.</small>
                        </div>

                        <button type="button" id="generate-concept-button" class="btn btn-primary"
                            data-lang-en="Generate Concept" data-lang-es="Generar Concepto" data-lang-vi="Tạo ý tưởng" data-lang-ja="コンセプトを生成" data-lang-zhcn="生成概念"
                        >Generate Concept</button>
                    </form>
                </div>
            </div>

            <!-- Error Message Area -->
            <div id="error-message" class="error-message"
                 data-lang-en="An error occurred. Please check your input or try again later." data-lang-es="Ocurrió un error. Por favor, revisa tu entrada o inténtalo de nuevo más tarde." data-lang-vi="Đã xảy ra lỗi. Vui lòng kiểm tra đầu vào của bạn hoặc thử lại sau." data-lang-ja="エラーが発生しました。入力を確認するか、後でもう一度お試しください。" data-lang-zhcn="发生错误。请检查您的输入或稍后再试。"
                 data-error-key="errorUnknown"
            ></div>

            <!-- Results Area (Cards) -->
            <div class="results-section" id="results-output-area">
                <!-- Concept Card -->
                 <div id="result-concept-card" class="result-card" style="grid-column: 1 / -1; display: none;">
                     <h2>
                         <span data-lang-en="Concept / Key Visual" data-lang-es="Concepto / Visual Clave" data-lang-vi="Ý tưởng / Hình ảnh chủ đạo" data-lang-ja="コンセプト / キービジュアル" data-lang-zhcn="概念 / 关键视觉"
                         >Concept / Key Visual</span>
                     </h2>
                     <div class="card-content placeholder-notice" id="result-concept">
                         <p class="placeholder-notice"
                            data-placeholder-key="conceptPlaceholder"
                            data-lang-en="Your generated concept will appear here..." data-lang-es="Tu concepto generado aparecerá aquí..." data-lang-vi="Ý tưởng được tạo của bạn sẽ xuất hiện ở đây..." data-lang-ja="生成されたコンセプトがここに表示されます..." data-lang-zhcn="您生成的概念将显示在此处..."
                         >Your generated concept will appear here...</p>
                     </div>
                     <!-- Action buttons -->
                     <div class="action-buttons">
                         <button id="explore-more-button" class="btn btn-secondary" disabled
                             data-lang-en="Explore More Details" data-lang-es="Explorar Más Detalles" data-lang-vi="Khám phá thêm chi tiết" data-lang-ja="詳細をさらに探索" data-lang-zhcn="探索更多细节"
                         >Explore More Details</button>
                         <button id="regenerate-button" class="btn btn-secondary" disabled
                             data-lang-en="Re-Generate Concept" data-lang-es="Re-Generar Concepto" data-lang-vi="Tạo lại ý tưởng" data-lang-ja="コンセプトを再生成" data-lang-zhcn="重新生成概念"
                         >Re-Generate Concept</button>
                     </div>
                 </div>

                 <!-- Detailed Results Grid (Populated after 'Explore More', single column) -->
                 <div class="results-grid" id="detailed-results-grid" style="display: none;">
                     <div id="result-requirements-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Requirements for MV" data-lang-es="Requisitos para el MV" data-lang-vi="Yêu cầu đối với MV" data-lang-ja="MVの要件" data-lang-zhcn="MV 要求"
                             >Requirements for MV</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-requirements">
                            <ul class="placeholder-notice">
                                <li class="placeholder-notice"
                                    data-placeholder-key="requirementsPlaceholder"
                                    data-lang-en="Requirements list will appear here..." data-lang-es="La lista de requisitos aparecerá aquí..." data-lang-vi="Danh sách yêu cầu sẽ xuất hiện ở đây..." data-lang-ja="要件リストがここに表示されます..." data-lang-zhcn="要求列表将显示在此处..."
                                >Requirements list will appear here...</li>
                            </ul>
                         </div>
                     </div>

                     <!-- == BUDGET CARD STRUCTURE == -->
                     <div id="result-budget-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Estimated Budget" data-lang-es="Presupuesto Estimado" data-lang-vi="Ngân sách ước tính" data-lang-ja="推定予算" data-lang-zhcn="预估预算"
                             >Estimated Budget</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-budget">
                             <!-- Container for the 3 budget columns -->
                             <div class="budget-columns-container placeholder-notice">
                                 <!-- Placeholder Text (will be replaced by JS if columns are generated) -->
                                 <p data-placeholder-key="budgetPlaceholder" class="placeholder-notice"
                                    data-lang-en="Budget details will appear here..." data-lang-es="Los detalles del presupuesto aparecerán aquí..." data-lang-vi="Chi tiết ngân sách sẽ xuất hiện ở đây..." data-lang-ja="予算の詳細がここに表示されます..." data-lang-zhcn="预算细节将显示在此处..."
                                 >Budget details will appear here...</p>
                                 <!-- Low, Mid, High Columns will be generated here by JS -->
                             </div>
                             <!-- Note about budget estimates -->
                             <small style="display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;"
                                data-lang-en="Note: Budgets are conceptual estimates and vary widely based on specifics like location, crew size, equipment, talent, etc." data-lang-es="Nota: Los presupuestos son estimaciones conceptuales y varían ampliamente según detalles como ubicación, equipo, equipamiento, talento, etc." data-lang-vi="Lưu ý: Ngân sách là ước tính khái niệm và thay đổi rất nhiều dựa trên các chi tiết cụ thể như địa điểm, quy mô đoàn làm phim, thiết bị, tài năng, v.v." data-lang-ja="注：予算は概念的な見積もりであり、場所、スタッフの規模、機材、タレントなどの詳細によって大きく変動します。" data-lang-zhcn="注意：预算是概念性估算，并根据地点、团队规模、设备、人才等具体情况而有很大差异。"
                                data-placeholder-key="budgetNotePlaceholder"
                             >Note: Budgets are conceptual estimates and vary widely based on specifics like location, crew size, equipment, talent, etc.</small>
                         </div>
                     </div>
                     <!-- == END BUDGET CARD STRUCTURE == -->

                     <div id="result-visuals-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Visual Demo (Key Images)" data-lang-es="Demo Visual (Imágenes Clave)" data-lang-vi="Minh họa Hình ảnh (Ảnh chính)" data-lang-ja="ビジュアルデモ（キーイメージ）" data-lang-zhcn="视觉演示（关键图像）"
                             >Visual Demo (Key Images)</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-visuals">
                            <div class="image-placeholder-container placeholder-notice">
                                <p data-placeholder-key="visualsPlaceholder" class="placeholder-notice"
                                   data-lang-en="Key visual descriptions will appear here..." data-lang-es="Las descripciones visuales clave aparecerán aquí..." data-lang-vi="Mô tả hình ảnh chính sẽ xuất hiện ở đây..." data-lang-ja="主要なビジュアルの説明がここに表示されます..." data-lang-zhcn="关键视觉描述将显示在此处..."
                                >Key visual descriptions will appear here...</p>
                            </div>
                             <small style="display: block; margin-top: 1rem; font-size: 0.85em;"
                                data-lang-en="Illustrative images based on descriptions." data-lang-es="Imágenes ilustrativas basadas en descripciones." data-lang-vi="Hình ảnh minh họa dựa trên mô tả." data-lang-ja="説明に基づいた説明的な画像。" data-lang-zhcn="基于描述的说明性图片。"
                                data-placeholder-key="visualsNotePlaceholder"
                             >Illustrative images based on descriptions.</small>
                         </div>
                     </div>

                     <div id="result-moodboard-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Moodboard Influences" data-lang-es="Influencias del Moodboard" data-lang-vi="Ảnh hưởng Moodboard" data-lang-ja="ムードボードの影響" data-lang-zhcn="情绪板影响"
                             >Moodboard Influences</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-moodboard">
                             <p data-placeholder-key="moodboardDescPlaceholder" id="moodboard-description" class="placeholder-notice"
                                data-lang-en="Moodboard description will appear here..." data-lang-es="La descripción del moodboard aparecerá aquí..." data-lang-vi="Mô tả moodboard sẽ xuất hiện ở đây..." data-lang-ja="ムードボードの説明がここに表示されます..." data-lang-zhcn="情绪板描述将显示在此处..."
                             >Moodboard description will appear here...</p>
                             <div class="image-placeholder-container placeholder-notice" id="moodboard-images">
                                <p data-placeholder-key="moodboardImgsPlaceholder" class="placeholder-notice"
                                   data-lang-en="Moodboard influence images will appear here..." data-lang-es="Las imágenes de influencia del moodboard aparecerán aquí..." data-lang-vi="Hình ảnh ảnh hưởng moodboard sẽ xuất hiện ở đây..." data-lang-ja="ムードボードの影響画像がここに表示されます..." data-lang-zhcn="情绪板影响图片将显示在此处..."
                                >Moodboard influence images will appear here...</p>
                             </div>
                              <small style="display: block; margin-top: 1rem; font-size: 0.85em;"
                                data-lang-en="Visual styles and elements for inspiration." data-lang-es="Estilos visuales y elementos para inspiración." data-lang-vi="Phong cách và yếu tố hình ảnh để lấy cảm hứng." data-lang-ja="インスピレーションのための視覚的なスタイルと要素。" data-lang-zhcn="用于灵感的视觉风格和元素。"
                                data-placeholder-key="moodboardNotePlaceholder"
                              >Visual styles and elements for inspiration.</small>
                         </div>
                     </div>

                     <div id="result-palette-card" class="result-card" style="display: none;">
                         <h2>
                             <span data-lang-en="Color Palette" data-lang-es="Paleta de Colores" data-lang-vi="Bảng màu" data-lang-ja="カラーパレット" data-lang-zhcn="调色板"
                             >Color Palette</span>
                         </h2>
                         <div class="card-content placeholder-notice" id="result-palette">
                             <div class="color-palette-display placeholder-notice">
                                <p data-placeholder-key="palettePlaceholder" class="placeholder-notice"
                                   data-lang-en="Color palette will appear here..." data-lang-es="La paleta de colores aparecerá aquí..." data-lang-vi="Bảng màu sẽ xuất hiện ở đây..." data-lang-ja="カラーパレットがここに表示されます..." data-lang-zhcn="调色板将显示在此处..."
                                >Color palette will appear here...</p>
                             </div>
                         </div>
                     </div>
                 </div><!-- End #detailed-results-grid -->
            </div> <!-- End #results-output-area -->

            <!-- Back button for the feature page -->
             <button class="btn btn-secondary btn-back" data-target="home" style="display: block; width: fit-content; margin: 3rem auto 0 auto;"
                data-lang-en="Back to Home" data-lang-es="Volver al Inicio" data-lang-vi="Về Trang chủ" data-lang-ja="ホームに戻る" data-lang-zhcn="返回首页"
             >Back to Home</button>

        </section>
    </main>

    <footer class="main-footer">
        <div class="container">
            <p>&copy; 2025 MVPot. All rights reserved.</p>
            <!-- <p><a href="#">Privacy Policy</a> | <a href="#">Terms of Service</a></p> -->
        </div>
    </footer>


    <!-- ========= START JAVASCRIPT ========= -->
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element References ---
        const navLinks = document.querySelectorAll('.nav-link');
        const pages = document.querySelectorAll('.page');
        const exploreButton = document.getElementById('explore-button');
        const backButtons = document.querySelectorAll('.btn-back');
        const generateConceptButton = document.getElementById('generate-concept-button');
        const resultsOutputArea = document.getElementById('results-output-area');
        const conceptCard = document.getElementById('result-concept-card');
        const detailedResultsGrid = document.getElementById('detailed-results-grid');
        const exploreMoreButton = document.getElementById('explore-more-button');
        const regenerateButton = document.getElementById('regenerate-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const errorMessageDiv = document.getElementById('error-message');
        const recordAudioButton = document.getElementById('record-audio-button');
        const recordStatus = document.getElementById('record-status');
        const recordingAnimation = document.getElementById('recording-animation');
        const recordStatusText = document.getElementById('record-status-text');
        const lyricsInput = document.getElementById('lyrics-input');
        const keywordsInput = document.getElementById('keywords-input');
        const genreSelect = document.getElementById('genre-select');
        const trackUploadInput = document.getElementById('track-upload');
        const transcriptGroup = document.getElementById('transcript-group');
        const transcriptOutput = document.getElementById('transcript-output');
        const languageSelect = document.getElementById('language-select');
        const allTranslatableElements = document.querySelectorAll('[data-lang-en], [data-lang-en-placeholder]');

        // --- State Variables ---
        let currentInputs = null; // Store form inputs for regeneration/exploration
        let currentLang = 'en'; // Default language
        let activePage = 'home'; // Track current page

        // --- Audio Recording Variables ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordedAudioBlob = null;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let finalTranscript = '';
        let isSpeechRecognitionSupported = !!SpeechRecognition;

        // --- Mapping for Section Processing & Placeholders ---
        const sections = { // Maps Header Title to Content Div ID
            'Concept / Key Visual': 'result-concept',
            'Requirements for MV': 'result-requirements',
            'Estimated Budget': 'result-budget', // <<< Keep this mapping
            'Visual Demo (Key Image Descriptions)': 'result-visuals', // Adjusted key to match prompt
            'Moodboard Influences': 'result-moodboard',
            'Color Palette': 'result-palette'
        };
        const cardElements = { // Maps Header Title to Card Element
            'Concept / Key Visual': conceptCard,
            'Requirements for MV': document.getElementById('result-requirements-card'),
            'Estimated Budget': document.getElementById('result-budget-card'), // <<< Keep this mapping
            'Visual Demo (Key Image Descriptions)': document.getElementById('result-visuals-card'), // Adjusted key
            'Moodboard Influences': document.getElementById('result-moodboard-card'),
            'Color Palette': document.getElementById('result-palette-card')
         };

        // --- Page Navigation ---
        function showPage(pageId) {
            activePage = pageId;
            pages.forEach(page => {
                page.classList.toggle('active', page.id === `${pageId}-page`);
            });
            navLinks.forEach(link => {
                 const linkPage = link.getAttribute('data-page');
                 if (link.classList.contains('logo') || (link.parentElement && link.parentElement.tagName === 'LI')) {
                     link.classList.toggle('active', linkPage === pageId);
                 }
            });
            window.scrollTo(0, 0);
             if (pageId !== 'feature') {
                 resultsOutputArea.style.display = 'none';
                 detailedResultsGrid.style.display = 'none';
                 conceptCard.style.display = 'none';
                 errorMessageDiv.style.display = 'none';
                 clearResultsContent();
             }
            console.log(`Navigated to: ${pageId}`);
        }

        // --- Loading Overlay Control ---
        function showLoading(messageKey = "generatingCreativeSparks", fallbackMessage = "Generating creative sparks...") {
             if (!loadingOverlay) return;
             const textElement = loadingOverlay.querySelector('p');
             if (textElement) {
                 const translatedMessage = getTranslatedText(textElement, messageKey, false, fallbackMessage);
                 textElement.textContent = translatedMessage;
                 textElement.dataset.lastKey = messageKey; // Store key for re-translation
             }
             loadingOverlay.classList.add('show');
             // Disable buttons
             if(generateConceptButton) generateConceptButton.disabled = true;
             if(exploreMoreButton) exploreMoreButton.disabled = true;
             if(regenerateButton) regenerateButton.disabled = true;
             if(recordAudioButton) recordAudioButton.disabled = true;
        }
        function hideLoading() {
            if (!loadingOverlay) return;
            loadingOverlay.classList.remove('show');
             // Re-enable buttons (consider states)
             if(generateConceptButton) generateConceptButton.disabled = false;
             if(exploreMoreButton) exploreMoreButton.disabled = !currentInputs;
             if(regenerateButton) regenerateButton.disabled = !currentInputs;
             if(recordAudioButton) {
                  recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported) || isRecording;
             }
        }

        // --- Microphone Recording & Speech Recognition Logic ---
         if (recordAudioButton) {
            recordAudioButton.addEventListener('click', handleRecordButtonClick);
            if (!navigator.mediaDevices?.getUserMedia) {
                updateRecordStatus('Audio recording not supported.', 'error', true, 'statusAudioNotSupported');
                recordAudioButton.disabled = true;
            } else if (!isSpeechRecognitionSupported) {
                updateRecordStatus('Speech recognition not supported.', 'error', true, 'statusSpeechRecNotSupported');
                recordAudioButton.disabled = true;
            }
        }

        async function handleRecordButtonClick() {
             if (!navigator.mediaDevices?.getUserMedia) { updateRecordStatus('Recording not supported by browser.', 'error', true, 'statusAudioNotSupported'); return; }
             if (!isSpeechRecognitionSupported) { updateRecordStatus('Speech recognition not supported.', 'error', true, 'statusSpeechRecNotSupported'); return; }

            if (!isRecording) { // Start Recording
                try {
                    recordedAudioBlob = null; trackUploadInput.value = ''; transcriptOutput.value = '';
                    finalTranscript = ''; transcriptGroup.style.display = 'none'; clearRecordStatus();
                    updateRecordStatus('Requesting mic access...', '', false, 'statusRequestingMic');
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    updateRecordStatus('', 'recording', false); // UI updated below

                    // MediaRecorder
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
                    mediaRecorder.onstop = () => {
                        recordedAudioBlob = (audioChunks.length > 0) ? new Blob(audioChunks, { type: 'audio/webm;codecs=opus' }) : null;
                        audioChunks = []; stream.getTracks().forEach(track => track.stop());
                        updateRecordingUI(false);
                        if (!recognition || !recognition.recognizing) { updateFinalRecordStatus(); }
                    };
                     mediaRecorder.onerror = (event) => {
                        console.error("MediaRecorder error:", event.error);
                        const errorMsg = getTranslatedText(null, 'statusRecordingError', false, `Recording error: ${event.error.name}`).replace('${errorName}', event.error.name);
                        updateRecordStatus(errorMsg, 'error', true);
                        if (recognition?.abort) { try { recognition.abort(); } catch(e){} }
                        stream.getTracks().forEach(track => track.stop()); updateRecordingUI(false);
                     };

                    // Speech Recognition
                    recognition = new SpeechRecognition();
                    recognition.continuous = true; recognition.interimResults = true;
                    const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' };
                    recognition.lang = bcp47Map[currentLang] || (currentLang.includes('-') ? currentLang : `${currentLang}-${currentLang.toUpperCase()}`);
                    console.log("SpeechRecognition language set to:", recognition.lang);

                    recognition.onresult = (event) => {
                        let interimTranscript = ''; finalTranscript = '';
                        for (let i = event.resultIndex; i < event.results.length; ++i) {
                            if (event.results[i].isFinal) { finalTranscript += event.results[i][0].transcript + ' '; }
                            else { interimTranscript += event.results[i][0].transcript; }
                        }
                        const currentFullTranscript = (finalTranscript + interimTranscript).trim();
                        transcriptOutput.value = currentFullTranscript;
                        if (currentFullTranscript) { transcriptGroup.style.display = 'block'; }
                         updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing');
                    };
                    recognition.onerror = (event) => {
                        console.error("Speech Recognition Error:", event.error, event.message);
                        let errorMsgKey = 'transcriptionErrorGeneric', errorParam = event.error;
                         if (event.error === 'no-speech') { errorMsgKey = 'transcriptionErrorNoSpeech'; errorParam = '';}
                         else if (event.error === 'audio-capture') { errorMsgKey = 'transcriptionErrorMicProblem'; errorParam = ''; }
                         else if (event.error === 'not-allowed') { errorMsgKey = 'transcriptionErrorPermission'; errorParam = '';}
                         else if (event.error === 'network') { errorMsgKey = 'transcriptionErrorNetwork'; errorParam = '';}
                         const translatedError = getTranslatedText(null, errorMsgKey, false, `Transcription error: ${errorParam}`);
                         if (!recordStatus?.classList.contains('error')) { updateRecordStatus(translatedError, 'error', true, errorMsgKey); }
                         if (mediaRecorder?.state === "recording" && event.error !== 'no-speech') { try { mediaRecorder.stop(); } catch(e){} }
                    };
                    recognition.onstart = () => { console.log("Speech recognition started."); updateRecordStatus(getTranslatedText(null, 'statusTranscribing', false, 'Transcribing...'), 'transcribing', false, 'statusTranscribing'); };
                    recognition.onend = () => {
                        console.log("Speech recognition ended."); finalTranscript = finalTranscript.trim();
                        transcriptOutput.value = finalTranscript;
                         if (!finalTranscript && transcriptGroup.style.display === 'block') { transcriptGroup.style.display = 'none'; }
                         if (!isRecording) { updateFinalRecordStatus(); }
                    };

                    // Start
                    audioChunks = []; mediaRecorder.start(); recognition.start(); updateRecordingUI(true);

                } catch (err) {
                    console.error("Error accessing microphone:", err);
                     let errorMsgKey = 'micErrorGeneric';
                     if (err.name === 'NotAllowedError') { errorMsgKey = 'micErrorPermission'; }
                     else if (err.name === 'NotFoundError') { errorMsgKey = 'micErrorNotFound'; }
                     else if (err.name === 'NotReadableError') { errorMsgKey = 'micErrorHardware'; }
                     updateRecordStatus(getTranslatedText(null, errorMsgKey, false, 'Microphone access error.'), 'error', true, errorMsgKey);
                    updateRecordingUI(false);
                }
            } else { // Stop Recording
                 if (mediaRecorder?.state === "recording") {
                    updateRecordStatus(getTranslatedText(null, 'statusStopping', false, 'Stopping...'), '', false, 'statusStopping');
                    try { mediaRecorder.stop(); } catch(e){}
                }
                if (recognition?.stop) {
                     try { recognition.stop(); }
                     catch (e) { if (!isRecording) { updateFinalRecordStatus(); } }
                } else if (!isRecording) { updateFinalRecordStatus(); }
            }
        }

         function updateFinalRecordStatus() {
             setTimeout(() => {
                  if (recordStatus?.classList.contains('error')) return; // Don't overwrite error
                  let finalStatusMsgKey = 'stoppedStatus', finalStatusClass = '', isPersistent = false;
                  if (recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'recordTranscriptComplete'; finalStatusClass = 'complete'; isPersistent = true; }
                  else if (recordedAudioBlob && !finalTranscript) { finalStatusMsgKey = 'recordCompleteNoTranscript'; finalStatusClass = 'complete'; isPersistent = true; }
                  else if (!recordedAudioBlob && finalTranscript) { finalStatusMsgKey = 'transcriptCompleteNoRecord'; finalStatusClass = 'complete'; isPersistent = true; }
                  updateRecordStatus(getTranslatedText(null, finalStatusMsgKey, false, 'Stopped.'), finalStatusClass, isPersistent, finalStatusMsgKey);
             }, 100);
         }

        function updateRecordingUI(recording) {
            if (!recordAudioButton) return; isRecording = recording;
            const recordKey = 'record', stopKey = 'stop';
            const buttonText = recording ? getTranslatedText(recordAudioButton, stopKey, false, 'Stop Recording') : getTranslatedText(recordAudioButton, recordKey, false, 'Record Audio');
            recordAudioButton.textContent = buttonText; recordAudioButton.disabled = false;
            if (recording) {
                recordAudioButton.classList.remove('btn-warning'); recordAudioButton.classList.add('btn-danger');
                if(recordingAnimation) recordingAnimation.style.display = 'inline-block';
                 updateRecordStatus(getTranslatedText(null, 'statusRecording', false, 'Recording...'), 'recording', false, 'statusRecording');
            } else {
                recordAudioButton.classList.remove('btn-danger'); recordAudioButton.classList.add('btn-warning');
                if(recordingAnimation) recordingAnimation.style.display = 'none';
                recordAudioButton.disabled = !(navigator.mediaDevices?.getUserMedia && isSpeechRecognitionSupported);
            }
         }

        function updateRecordStatus(message, statusClass = '', persistent = false, translationKey = '') {
            if (!recordStatus || !recordStatusText || !recordingAnimation) return;
             if (updateRecordStatus.timeoutId) { clearTimeout(updateRecordStatus.timeoutId); updateRecordStatus.timeoutId = null; }
             const displayMessage = translationKey ? getTranslatedText(null, translationKey, false, message) : message;
            recordStatusText.textContent = displayMessage;
            recordStatus.className = 'record-status-base'; // Reset
            recordStatus.dataset.statusKey = translationKey; recordStatus.dataset.statusFallback = message; // Store for re-translation
            if (statusClass) recordStatus.classList.add(statusClass);
            recordingAnimation.style.display = (statusClass === 'recording' || statusClass === 'transcribing') ? 'inline-block' : 'none';
            if (!persistent && statusClass !== 'error' && displayMessage) {
                updateRecordStatus.timeoutId = setTimeout(() => {
                     if (recordStatusText.textContent === displayMessage && recordStatus.dataset.statusKey === translationKey) { clearRecordStatus(); }
                }, 4000);
            }
         }
         updateRecordStatus.timeoutId = null;

         function clearRecordStatus() {
            if (recordStatusText) recordStatusText.textContent = '';
            if (recordStatus) { recordStatus.className = 'record-status-base'; delete recordStatus.dataset.statusKey; delete recordStatus.dataset.statusFallback; }
            if (recordingAnimation) recordingAnimation.style.display = 'none';
            if (updateRecordStatus.timeoutId) { clearTimeout(updateRecordStatus.timeoutId); updateRecordStatus.timeoutId = null; }
         }

        if(trackUploadInput) {
             trackUploadInput.addEventListener('change', () => {
                 if (trackUploadInput.files.length > 0) {
                     if (isRecording) {
                         if (mediaRecorder?.state === "recording") try { mediaRecorder.stop(); } catch(e){}
                         if (recognition?.abort) try { recognition.abort(); } catch(e){}
                         updateRecordingUI(false);
                     }
                     recordedAudioBlob = null; transcriptOutput.value = ''; finalTranscript = '';
                     transcriptGroup.style.display = 'none';
                     updateRecordStatus(getTranslatedText(null, 'statusFileSelected', false, 'File selected.'), 'complete', true, 'statusFileSelected');
                     console.log("File selected, cleared recording state.");
                 }
             });
        }

        // --- Gemini API Call Helper ---
        async function callGeminiAPI(promptText, loadingMessageKey = "generatingCreativeSparks", loadingFallback = "Generating...") {
            // --- !!! EXTREME SECURITY WARNING: API KEY HARDCODED IN FRONTEND !!! ---
            // This key is exposed to anyone viewing the page source code.
            // This is **NOT** safe for production environments.
            // For any real application, you MUST use a backend server or cloud function
            // to proxy the API calls and keep your key secure.
            const GEMINI_API_KEY = "AIzaSyB5c-hp-QeKBpBTz8qwANe4j5Kc4dZ_bWM"; // <-- VERY INSECURE - MOVE TO BACKEND
            // --- !!! END SECURITY WARNING !!! ---

            if (!GEMINI_API_KEY || GEMINI_API_KEY.startsWith("YOUR_") || GEMINI_API_KEY.length < 30) {
                 displayError(getTranslatedText(null, 'errorApiKeyInvalid', false, "API Key is missing or invalid. Configure it securely (backend recommended)."), 'errorApiKeyInvalid');
                 return null;
            }
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
            showLoading(loadingMessageKey, loadingFallback);

            const requestBody = {
                contents: [{ parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.75, maxOutputTokens: 4096 },
                safetySettings: [ /* Standard safety settings */
                   { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                ]
            };

            try {
                console.log("Sending API request to Gemini...");
                const response = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });
                const responseData = await response.json();
                console.log("Raw API Response:", responseData);

                if (!response.ok) {
                     const errorDetail = responseData?.error?.message || `HTTP Error: ${response.status}`;
                     const httpErrorMsg = getTranslatedText(null, 'errorApiHttp', false, `API request failed: ${errorDetail}`).replace('${errorDetail}', errorDetail);
                     throw new Error(httpErrorMsg);
                }
                 const candidate = responseData?.candidates?.[0];
                 if (!candidate || responseData?.promptFeedback?.blockReason || candidate.finishReason === "SAFETY") {
                     const reason = candidate?.finishReason || responseData?.promptFeedback?.blockReason || "Unknown Safety Block";
                     const blockMessage = getTranslatedText(null, 'errorApiBlocked', false, `Content blocked due to safety filters (Reason: ${reason}). Please revise your input.`)
                                           .replace('${reason}', reason);
                     throw new Error(blockMessage);
                 }
                 if (responseData?.error) {
                     const apiErrorMsg = getTranslatedText(null, 'errorApiGeneral', false, `API returned an error: ${responseData.error.message}`).replace('${errorMessage}', responseData.error.message);
                     throw new Error(apiErrorMsg);
                 }

                 const finishReason = candidate.finishReason;
                 if (finishReason && !["STOP", "MAX_TOKENS"].includes(finishReason)) {
                     console.warn(`Generation finished abnormally. Reason: ${finishReason}`);
                 }
                 if (finishReason === "MAX_TOKENS") { console.warn("Generation stopped due to maximum token limit."); }

                 if (candidate?.content?.parts?.[0]?.text) {
                     return candidate.content.parts[0].text.trim();
                 } else {
                     throw new Error(getTranslatedText(null, 'errorApiEmptyResponse', false, "Received an unexpected or empty text response from the AI."));
                 }

            } catch (error) {
                console.error("Error during Gemini fetch or processing:", error);
                // Determine Error Key from Message
                 let errorKey = 'errorUnknown';
                 const msg = String(error.message).toLowerCase();
                 if (msg.includes("api key") || msg.includes("invalid")) errorKey = 'errorApiKeyInvalid';
                 else if (msg.includes("http error")) errorKey = 'errorApiHttp';
                 else if (msg.includes("blocked") || msg.includes("safety filter")) errorKey = 'errorApiBlocked';
                 else if (msg.includes("api returned an error")) errorKey = 'errorApiGeneral';
                 else if (msg.includes("no response candidate")) errorKey = 'errorApiNoCandidate';
                 else if (msg.includes("empty text response")) errorKey = 'errorApiEmptyResponse';
                 displayError(error.message, errorKey);
                 return null;
            } finally {
                hideLoading();
            }
        }

        // --- Generate Initial Concept ---
        async function handleGenerateConcept() {
            const lyrics = lyricsInput.value.trim();
            const keywords = keywordsInput.value.trim();
            const selectedGenre = genreSelect.value;
            const singingTranscript = transcriptOutput.value.trim();

             // Validation
             let validationError = false, errorMsg = '', errorKey = '', focusEl = null;
             if (!lyrics) { errorMsg = getTranslatedText(lyricsInput, 'placeholder', true) || "Provide lyrics."; errorKey = 'validationLyricsMissing'; focusEl = lyricsInput; validationError = true; }
             else if (!keywords) { errorMsg = getTranslatedText(keywordsInput, 'placeholder', true) || "Provide keywords."; errorKey = 'validationKeywordsMissing'; focusEl = keywordsInput; validationError = true; }
             else if (!selectedGenre) { errorMsg = getTranslatedText(genreSelect.options[0]) || "Select genre."; errorKey = 'validationGenreMissing'; focusEl = genreSelect; validationError = true; }
             if(validationError) { displayError(errorMsg, errorKey); focusEl?.focus(); return; }

            currentInputs = { lyrics, keywords, selectedGenre, singingTranscript };
            clearResultsAndErrors();

            // Prompt for ONLY Concept
             const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Analyze the following song details:
**Lyrics:**\n\`\`\`\n${lyrics}\n\`\`\`${singingTranscript ? `\n**Singing Transcript (Optional Context):**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}\n**Music Genre:** ${selectedGenre}
Generate **ONLY** the "Concept / Key Visual" section for a music video based on these details. Structure your response *exactly* like this, starting directly with the header and providing content below it in well-written English:
## Concept / Key Visual
(Provide a concise, compelling core concept description here. Mention 1-2 key visual motifs or scenes.)`;

            const loadingMsgKey = "generatingConcept";
            const loadingFallback = "Generating Concept...";
            const generatedText = await callGeminiAPI(prompt, loadingMsgKey, loadingFallback);

            if (generatedText) {
                resultsOutputArea.style.display = 'block';
                conceptCard.style.display = 'flex';
                detailedResultsGrid.style.display = 'none';
                const conceptContentDiv = document.getElementById('result-concept');
                 if (conceptContentDiv) { conceptContentDiv.innerHTML = ''; conceptContentDiv.classList.remove('placeholder-notice'); }
                parseAndDisplayResults(generatedText); // Populates concept card
                conceptCard.style.transitionDelay = '0s'; conceptCard.classList.add('visible'); // Animate
                 if(exploreMoreButton) exploreMoreButton.disabled = false;
                 if(regenerateButton) regenerateButton.disabled = false;
                 setTimeout(() => { resultsOutputArea.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);
            }
        }

        // --- Explore More Details ---
        async function handleExploreMore() {
            if (!currentInputs) { displayError(getTranslatedText(null, 'errorExploreNoConcept', false, "Generate concept first."), 'errorExploreNoConcept'); return; }
            if(exploreMoreButton) exploreMoreButton.disabled = true;
            if(regenerateButton) regenerateButton.disabled = true;

            // --- <<< UPDATED Prompt for Detailed Results (including budget format) >>> ---
            const { lyrics, keywords, selectedGenre, singingTranscript } = currentInputs;
            const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Based on the original song details:
**Lyrics:**\n\`\`\`\n${lyrics}\n\`\`\`${singingTranscript ? `\n**Singing Transcript (Optional Context):**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}\n**Music Genre:** ${selectedGenre}
Provide the **remaining detailed sections** (excluding 'Concept / Key Visual'). Structure *exactly* like this in English:

## Requirements for MV
(* or - list item: Detail about location, casting, props, wardrobe, cinematography, VFX, editing style, etc.)

## Estimated Budget
(**Low Budget:** ~$Range (Optional). Description of approach.
- Example Item - $Cost (Optional, list a few key cost drivers if applicable)

**Mid Budget:** ~$Range (Optional). Description of approach, potentially scaling up elements from Low.
- Example Item - $Cost

**High Budget:** ~$Range (Optional). Description of approach, allowing for higher production value.
- Example Item - $Cost
)

## Visual Demo (Key Image Descriptions)
(1. Vivid description of a key scene or visual moment.
2. Another vivid description.
3. A third vivid description.)

## Moodboard Influences
(A short sentence describing the overall mood and visual style.
* Specific visual element or reference (e.g., Film noir lighting).
* Another specific element (e.g., Wes Anderson symmetry).
* Style reference (e.g., Surrealist paintings).
* Color influence (e.g., Muted pastels).
* Textural element (e.g., Grainy film stock).
)

## Color Palette
(Strictly format: Color Name (#XXXXXX), Another Color (#XXXXXX), ...)

Adhere strictly to the format: Use the exact headers (##), use bullet points (* or -) for Requirements and Moodboard lists, use numbering (1., 2., 3.) for Visual Demo, use the bold format **Level Budget:** for budget tiers, and the exact comma-separated Name (#XXXXXX) format for colors. Provide detailed, relevant content for each section based on the song inputs. Use plausible USD ($) ranges for budget tiers (e.g., ~$1k-5k, ~$10k-30k, ~$50k+).`;

            const loadingMsgKey = "fetchingDetails";
            const loadingFallback = "Fetching More Details...";
            const generatedText = await callGeminiAPI(prompt, loadingMsgKey, loadingFallback);

            if (generatedText) {
                 clearDetailedResultsContentOnly(); // Clear placeholders
                 parseAndDisplayResults(generatedText); // Populate detail cards
                 detailedResultsGrid.style.display = 'grid'; // Show the grid

                 // Animate cards in
                 const detailCards = detailedResultsGrid.querySelectorAll('.result-card');
                 detailCards.forEach((card, index) => {
                     const contentDiv = card.querySelector('.card-content');
                     const hasRealContent = contentDiv && !contentDiv.classList.contains('placeholder-notice') && contentDiv.innerHTML.trim() !== '' && !contentDiv.querySelector('.placeholder-notice');
                     if (card.style.display === 'flex' && hasRealContent) {
                         card.style.transitionDelay = `${index * 0.1}s`; card.classList.add('visible');
                     } else if (card.style.display === 'flex') { // Show immediately if only placeholder/error
                         card.style.opacity = 1; card.style.transform = 'translateY(0)'; card.classList.remove('visible');
                     }
                 });
                 // Scroll to new cards
                  setTimeout(() => {
                    const firstDetailCard = detailedResultsGrid.querySelector('.result-card[style*="display: flex"]');
                    (firstDetailCard || detailedResultsGrid).scrollIntoView({ behavior: 'smooth', block: 'start' });
                  }, 150);
                 if (regenerateButton) regenerateButton.disabled = false; // Keep explore disabled, enable regenerate
            } else {
                 // Buttons re-enabled by hideLoading if API failed
                 if (exploreMoreButton) exploreMoreButton.disabled = false; // Re-enable explore on failure
                 if (regenerateButton) regenerateButton.disabled = currentInputs ? false : true;
            }
        }

        // --- Re-Generate Concept ---
        function handleRegenerateConcept() {
            clearResultsAndErrors();
            handleGenerateConcept(); // Restart the process
        }

        // --- Parsing and Displaying Results ---
        function parseAndDisplayResults(text) {
            console.log("Parsing AI response...");
            const lines = text.split('\n');
            let currentSectionKey = null; let contentBuffer = '';
            let foundAnySection = false; const processedSections = new Set();

            // Hide all detail cards initially (except concept if it's already shown)
             Object.values(cardElements).forEach(card => { if (card !== conceptCard) card.style.display = 'none'; });

            lines.forEach(line => {
                let matchedHeader = false;
                for (const title in sections) {
                    // Make regex more robust to handle slight variations in spacing or markdown emphasis
                    const escapedTitle = title.trim().replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    const headerRegex = new RegExp(`^\\s*##\\s*\\*?\\*?${escapedTitle}\\*?\\*?\\s*$`, 'i');
                    if (headerRegex.test(line.trim())) {
                        if (currentSectionKey && contentBuffer.trim()) {
                            const targetElementId = sections[currentSectionKey]; const targetCard = cardElements[currentSectionKey];
                            if (targetElementId && targetCard) {
                                try { processSectionContent(targetElementId, currentSectionKey, contentBuffer.trim()); processedSections.add(currentSectionKey); foundAnySection = true; }
                                catch (processError) { handleProcessingError(targetElementId, targetCard, currentSectionKey, processError); processedSections.add(currentSectionKey); }
                            }
                        }
                        currentSectionKey = title; contentBuffer = ''; matchedHeader = true; console.log(`--- Found Header: ${currentSectionKey} ---`); break;
                    }
                }
                if (!matchedHeader && currentSectionKey) { contentBuffer += line + '\n'; }
            });

            // Process last section
            if (currentSectionKey && contentBuffer.trim()) {
                 const targetElementId = sections[currentSectionKey]; const targetCard = cardElements[currentSectionKey];
                 if (targetElementId && targetCard) {
                     try { processSectionContent(targetElementId, currentSectionKey, contentBuffer.trim()); processedSections.add(currentSectionKey); foundAnySection = true; }
                     catch (processError) { handleProcessingError(targetElementId, targetCard, currentSectionKey, processError); processedSections.add(currentSectionKey); }
                 }
            }

             // Check for missing sections if details were requested
             const detailsRequested = detailedResultsGrid.style.display === 'grid' || // If grid is already shown
                                       (exploreMoreButton && exploreMoreButton.disabled && !regenerateButton?.disabled); // Or if explore was just clicked

            if (detailsRequested) {
                 Object.keys(sections).forEach(sectionTitle => {
                     if (sectionTitle !== 'Concept / Key Visual' && !processedSections.has(sectionTitle)) {
                         const targetElementId = sections[sectionTitle]; const targetCard = cardElements[sectionTitle];
                         const contentDiv = document.getElementById(targetElementId);
                         if (targetCard && contentDiv) {
                             console.warn(`Section "${sectionTitle}" not found in response. Displaying placeholder.`);
                             setPlaceholderForMissingSection(contentDiv, sectionTitle);
                             targetCard.style.display = 'flex'; // Show card with placeholder
                         }
                     }
                 });
            }

            if (!foundAnySection && text.trim()) {
                 // Avoid showing parse error if only concept was requested and received successfully
                 const onlyConceptRequested = exploreMoreButton && !exploreMoreButton.disabled;
                 const conceptWasProcessed = processedSections.has('Concept / Key Visual');

                 if (!(onlyConceptRequested && conceptWasProcessed)) {
                    displayError(getTranslatedText(null, 'errorParsingFailed', false, "Could not parse expected sections. Check AI response format. Raw output logged."), 'errorParsingFailed');
                    console.warn("Raw AI Response Text (Parsing Failed):\n", text);
                 } else {
                    console.log("Concept processed, other sections not requested yet or not found in initial response.");
                 }
            } else if (foundAnySection) {
                 console.log("Parsing complete."); errorMessageDiv.style.display = 'none';
            } else {
                 console.log("No sections found or text empty.");
                 displayError(getTranslatedText(null, 'errorApiEmptyResponse', false, "Received empty response."), 'errorApiEmptyResponse');
                 resultsOutputArea.style.display = 'none';
            }
        }

        // Helper for handling errors during section processing
        function handleProcessingError(targetElementId, targetCard, sectionKey, error) {
             console.error(`Error processing section "${sectionKey}":`, error);
              const contentDiv = document.getElementById(targetElementId);
             if (contentDiv) {
                  contentDiv.innerHTML = `<p class="placeholder-notice error">${getTranslatedText(null, 'errorDisplayingSection', false, 'Error displaying section.')}</p>`;
                  contentDiv.classList.add('placeholder-notice');
                  if (targetCard) targetCard.style.display = 'flex';
             }
        }

        // --- Process Individual Section Content ---
        function processSectionContent(elementId, sectionTitle, content) {
            const contentDiv = document.getElementById(elementId);
            if (!contentDiv) { console.error(`Content div not found: ${elementId}`); return; }
             contentDiv.innerHTML = ''; contentDiv.classList.remove('placeholder-notice');
             const parentCard = contentDiv.closest('.result-card');
             if (!parentCard) { console.error(`Parent card not found for ${elementId}`); return; }
             let sectionHasContent = false;

            try {
                console.log(`Processing Section: ${sectionTitle} into #${elementId}`);
                if (sectionTitle === 'Visual Demo (Key Image Descriptions)') {
                     const container = document.createElement('div'); container.className = 'image-placeholder-container'; contentDiv.appendChild(container);
                     const descs = content.split(/^\s*[1-9][0-9]*[\.\)\-]\s+/gm).filter(Boolean).map(d => d.trim().replace(/\n$/, ''));
                     if (descs.length > 0) { descs.slice(0, 3).forEach((d, i) => { if(d) { createImagePlaceholder(container, d, `v-${i}`); sectionHasContent = true; } }); } // Call REPLICATE version
                     if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noVisualsFound', false, 'No visuals found.')}</p>`; container.classList.add('placeholder-notice'); }
                     const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                     note.dataset.langEn = "Illustrative images based on descriptions."; note.dataset.placeholderKey="visualsNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);

                } else if (sectionTitle === 'Moodboard Influences') {
                     const descEl = document.createElement('p'); descEl.id = 'moodboard-description'; contentDiv.appendChild(descEl);
                     const imgContainer = document.createElement('div'); imgContainer.className = 'image-placeholder-container'; imgContainer.id = 'moodboard-images'; contentDiv.appendChild(imgContainer);
                     const lines = content.trim().split('\n'); let mainDesc = '', items = []; let readingDesc = true;
                     for (const line of lines) { const trimmed = line.trim(); if (trimmed.match(/^[\*\-]\s+/)) { readingDesc = false; items.push(trimmed.replace(/^[\*\-]\s+/, '').trim()); } else if (readingDesc && trimmed) { mainDesc += line + '\n'; } else if (!readingDesc && trimmed && items.length > 0) { items[items.length - 1] += '\n' + trimmed; } }
                     mainDesc = mainDesc.trim(); items = items.filter(Boolean);
                     if (mainDesc) { descEl.innerHTML = mainDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); descEl.style.display = 'block'; descEl.classList.remove('placeholder-notice'); sectionHasContent = true; }
                     else { descEl.innerHTML = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Desc...'); descEl.style.display = 'block'; descEl.classList.add('placeholder-notice'); descEl.dataset.placeholderKey="moodboardDescPlaceholder"; }
                     if (items.length > 0) { imgContainer.innerHTML = ''; imgContainer.classList.remove('placeholder-notice'); items.slice(0, 5).forEach((d, i) => { if(d) { createImagePlaceholder(imgContainer, d, `m-${i}`); sectionHasContent = true; } }); } // Call REPLICATE version
                     else { imgContainer.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'noMoodboardItemsFound', false, 'No items...')}</p>`; imgContainer.classList.add('placeholder-notice'); }
                     if (sectionHasContent) {
                         const note = document.createElement('small'); note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em;";
                         note.dataset.langEn = "Visual styles for inspiration."; note.dataset.placeholderKey="moodboardNotePlaceholder"; note.textContent = getTranslatedText(note, '', false, note.dataset.langEn); contentDiv.appendChild(note);
                     } else { contentDiv.innerHTML = `<p class="placeholder-notice" data-placeholder-key="moodboardDescPlaceholder">${getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Description missing.')}</p><div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="moodboardImgsPlaceholder">${getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'Images missing.')}</p></div>`; contentDiv.classList.add('placeholder-notice'); }

                // --- <<< START: Budget Section Processing (MODIFIED ERROR HANDLING) >>> ---
                } else if (sectionTitle === 'Estimated Budget') {
                     let container = contentDiv.querySelector('.budget-columns-container');
                     if (!container) {
                         container = document.createElement('div');
                         container.className = 'budget-columns-container';
                         contentDiv.appendChild(container);
                     } else {
                         container.innerHTML = ''; // Clear previous content if reusing
                     }
                     container.classList.remove('placeholder-notice'); // Assume content unless proven otherwise

                     const budgetRegex = /\*\*(Low\s*Budget|Mid\s*Budget|High\s*Budget)\*\*\s*:?\s*([\s\S]*?)(?=\n?\s*\*\*(?:Low|Mid|High)\s*Budget\*\*|$)/gi;
                     const budgetLevels = {};
                     let match;
                     let parsingSuccess = false; // Track if we found any budget sections

                     while ((match = budgetRegex.exec(content)) !== null) {
                         parsingSuccess = true;
                         const levelTitle = match[1].replace(/\s+/g, ' ').trim();
                         const levelKey = levelTitle.split(' ')[0];
                         let rawContent = match[2].trim();
                         let range = '';
                         let description = '';

                         const rangePatterns = [
                            /\(?[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*[-–—]\s*[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*(?:USD|EUR|GBP)?\)?/i,
                            /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*\+\s*(?:USD|EUR|GBP)?/i,
                            /[~\$€£]?\s*[\d,.]+\s*[kKmM]?\b\s*(?:USD|EUR|GBP)?/i
                         ];
                         for (const pattern of rangePatterns) {
                              const rangeMatch = rawContent.match(new RegExp(`^\\s*(${pattern.source})\\s*`, 'i'));
                              if (rangeMatch) {
                                  range = rangeMatch[1].trim();
                                  description = rawContent.substring(rangeMatch[0].length).trim();
                                  break;
                              }
                         }
                         if (!range) { description = rawContent; }
                         budgetLevels[levelKey] = { title: levelTitle, range: range, description: description };
                         console.log(`Parsed Budget Level: ${levelKey}, Range: ${range || 'N/A'}, Desc Start: ${description.substring(0,50)}...`);
                     }

                     const order = ["Low", "Mid", "High"];
                     let anyColumnHasContent = false;

                     order.forEach(levelKey => {
                         const colDiv = document.createElement('div');
                         colDiv.className = 'budget-column';

                         const titleH3 = document.createElement('h3');
                         const descP = document.createElement('p');

                         if (budgetLevels[levelKey]) {
                             const data = budgetLevels[levelKey];
                             titleH3.textContent = data.title + (data.range ? ` (${data.range})` : '');

                             let processedDesc = data.description;
                             const itemCostRegex = /^\s*[-*]?\s*([\w\s\(\)\/\'\".,]+?)\s*[:\-\–—]\s*([\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b(?:\s*[-–—]\s*[\$\€\£]?\s*[\d,.]+\s*[kKmM]?\b)?(?:\s*USD|\s*EUR|\s*GBP)?)\s*$/gm;
                             let itemBoxesHTML = '';
                             processedDesc = processedDesc.replace(itemCostRegex, (matchStr, item, cost) => {
                                 itemBoxesHTML += `<div class="budget-item-box">${item.trim()}: <strong>${cost.trim()}</strong></div>`;
                                 return '';
                             }).trim();
                             processedDesc = processedDesc.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                             processedDesc = processedDesc.replace(/\n/g, '<br>');
                             descP.innerHTML = processedDesc + itemBoxesHTML;

                             if(descP.innerHTML.trim() === ''){
                                descP.innerHTML = `(${getTranslatedText(null, 'budgetDetailsMissing', false, 'Details missing')})`;
                                descP.classList.add('placeholder-notice');
                             } else {
                                anyColumnHasContent = true;
                             }

                         } else {
                             titleH3.textContent = getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`);
                             descP.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`;
                             descP.classList.add('placeholder-notice');
                             colDiv.classList.add('placeholder-notice');
                         }

                         colDiv.appendChild(titleH3);
                         colDiv.appendChild(descP);
                         container.appendChild(colDiv);
                     });

                      // Check if overall parsing failed but content was present
                      if (!parsingSuccess && content.trim()) {
                         // Display raw text if parsing fails
                         container.innerHTML = `<pre>${content}</pre>`;
                         container.classList.add('raw-budget-output');
                         container.classList.add('placeholder-notice'); // Apply placeholder styles to the container holding the <pre>
                         console.warn("Budget parsing failed, displaying raw content.");
                      } else if (!anyColumnHasContent && !parsingSuccess) { // No sections found and content was empty/irrelevant
                         container.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'noBudgetContentFound', false, 'No budget details provided.')}</p>`;
                         container.classList.add('placeholder-notice');
                      } else {
                          sectionHasContent = true; // Mark section as having content if parsing was successful or columns were generated
                      }

                      // Ensure the budget note is present
                      let note = contentDiv.querySelector('small');
                      if (!note) {
                          note = document.createElement('small');
                          note.dataset.langEn = "Note: Budgets are conceptual estimates...";
                          note.dataset.placeholderKey="budgetNotePlaceholder";
                          contentDiv.appendChild(note);
                      }
                      note.style.cssText = "display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;";
                      note.textContent = getTranslatedText(note, '', false, note.dataset.langEn);
                // --- <<< END: Budget Section Processing >>> ---

                } else if (sectionTitle === 'Requirements for MV') {
                    const listEl = document.createElement('ul'); contentDiv.appendChild(listEl);
                    const items = content.trim().split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(item => item.trim().replace(/\n$/, ''));
                    if (items.length > 0) { items.forEach(item => { const li = document.createElement('li'); li.innerHTML = item.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>'); listEl.appendChild(li); }); sectionHasContent = true; }
                    else { listEl.innerHTML = `<li class="placeholder-notice" data-placeholder-key="requirementsPlaceholder">${getTranslatedText(null, 'noRequirementsFound', false, 'No requirements listed.')}.</li>`; listEl.classList.add('placeholder-notice'); }

                } else if (sectionTitle === 'Color Palette') {
                     const container = document.createElement('div'); container.className = 'color-palette-display'; contentDiv.appendChild(container);
                     sectionHasContent = createColorSwatches(container, content.trim());
                     if (!sectionHasContent) { container.innerHTML = `<p class="placeholder-notice" data-placeholder-key="palettePlaceholder">${getTranslatedText(null, 'noColorsFound', false, 'Could not parse colors.')}</p>`; container.classList.add('placeholder-notice'); }

                } else { // Default (e.g., Concept)
                     const pEl = document.createElement('p'); pEl.style.whiteSpace = 'pre-wrap';
                     const processedContent = content.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
                     pEl.innerHTML = processedContent; contentDiv.appendChild(pEl);
                     if (processedContent) sectionHasContent = true;
                }

                 if (!sectionHasContent && contentDiv.innerHTML.trim() === '') {
                    // Add a generic placeholder if processing resulted in nothing
                    contentDiv.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Content not available.')}</p>`;
                    contentDiv.classList.add('placeholder-notice');
                 }
                 parentCard.style.display = 'flex'; // Show card after processing

            } catch (error) {
                handleProcessingError(elementId, parentCard, sectionTitle, error);
            }
        }

         // --- Helper to set placeholders in cards for sections MISSING from AI response ---
         function setPlaceholderForMissingSection(contentDiv, sectionTitle) {
             if (!contentDiv) return;
             contentDiv.innerHTML = ''; // Clear existing content
             contentDiv.classList.add('placeholder-notice'); // Mark as placeholder container
             let placeholderKey = 'placeholderGeneric', fallbackText = 'Content missing.', placeholderHTML = '';

             switch (sectionTitle) {
                 case 'Requirements for MV':
                     placeholderKey = 'requirementsPlaceholder'; fallbackText = 'Requirements list...';
                     placeholderHTML = `<ul class="placeholder-notice"><li class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</li></ul>`;
                     break;
                 case 'Estimated Budget':
                     placeholderKey = 'budgetPlaceholder'; fallbackText = 'Budget details...';
                     const noteText = getTranslatedText(null, 'budgetNotePlaceholder', false, 'Note: Budgets are conceptual estimates...');
                     // Generate the 3 placeholder columns structure
                     placeholderHTML = `<div class="budget-columns-container">`; // Don't add placeholder-notice here, add to columns
                     ["Low", "Mid", "High"].forEach(levelKey => {
                        placeholderHTML += `<div class="budget-column placeholder-notice">
                                                <h3>${getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`)}</h3>
                                                <p class="placeholder-notice" data-placeholder-key="budgetDetailsMissing">(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})</p>
                                            </div>`;
                     });
                     placeholderHTML += `</div><small data-placeholder-key="budgetNotePlaceholder" style="display: block; margin-top: 1rem; font-size: 0.85em; text-align: center;">${noteText}</small>`;
                     break;
                 case 'Visual Demo (Key Image Descriptions)':
                     placeholderKey = 'visualsPlaceholder'; fallbackText = 'Visual descriptions...'; const visualsNote = getTranslatedText(null, 'visualsNotePlaceholder', false,'Illustrative images...');
                     placeholderHTML = `<div class="image-placeholder-container placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div><small data-placeholder-key="visualsNotePlaceholder">${visualsNote}</small>`;
                     break;
                 case 'Moodboard Influences':
                     const moodDesc = getTranslatedText(null, 'moodboardDescPlaceholder', false, 'Moodboard description...'); const moodImgs = getTranslatedText(null, 'moodboardImgsPlaceholder', false, 'Moodboard images...'); const moodNote = getTranslatedText(null, 'moodboardNotePlaceholder', false,'Visual styles...');
                     placeholderHTML = `<p data-placeholder-key="moodboardDescPlaceholder" id="moodboard-description" class="placeholder-notice">${moodDesc}</p><div class="image-placeholder-container placeholder-notice" id="moodboard-images"><p data-placeholder-key="moodboardImgsPlaceholder">${moodImgs}</p></div><small data-placeholder-key="moodboardNotePlaceholder">${moodNote}</small>`;
                     break;
                 case 'Color Palette':
                     placeholderKey = 'palettePlaceholder'; fallbackText = 'Color palette...';
                     placeholderHTML = `<div class="color-palette-display placeholder-notice"><p data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p></div>`;
                     break;
                 case 'Concept / Key Visual': // Handle concept placeholder specifically
                      placeholderKey = 'conceptPlaceholder'; fallbackText = 'Concept will appear here...';
                      placeholderHTML = `<p data-placeholder-key="${placeholderKey}" class="placeholder-notice">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
                      break;
                 default:
                      placeholderHTML = `<p class="placeholder-notice" data-placeholder-key="${placeholderKey}">${getTranslatedText(null, placeholderKey, false, fallbackText)}</p>`;
             }
             contentDiv.innerHTML = placeholderHTML;
         }

        // --- Image Generation Function (Using Replicate API) ---
        // --- !!! EXTREME SECURITY WARNING: API KEY HARDCODED IN FRONTEND !!! ---
        // This key is exposed to anyone viewing the page source code.
        // This is **NOT** safe for production environments.
        // For any real application, you MUST use a backend server or cloud function
        // to proxy the API calls and keep your key secure.
        const REPLICATE_API_TOKEN = "r8_QZQRzO6acAVB9pc9tocbz1fIjaWmomm1Wt4KO"; // <-- NEW KEY - VERY INSECURE IN FRONTEND
        // --- !!! END SECURITY WARNING !!! ---

        async function createImagePlaceholder(container, description, seedSuffix) {
             const figure = document.createElement('figure'); figure.className = 'image-placeholder';
             const img = document.createElement('img'); img.alt = `Loading...`; img.src = ''; img.loading = 'lazy';
             let phHeight = (container?.id === 'moodboard-images') ? 130 : 160;
             img.style.cssText = `height: ${phHeight}px; width: 100%; object-fit: cover; background-color: #444;`;
             const figcaption = document.createElement('figcaption');
             figcaption.innerHTML = description.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>').replace(/\n/g, '<br>');
             figure.appendChild(img); figure.appendChild(figcaption); container.appendChild(figure);

             // --- Replicate API Call Logic ---
             if (!REPLICATE_API_TOKEN || REPLICATE_API_TOKEN.startsWith('r8_') === false) { // Basic check
                 console.error("Replicate API token is missing or invalid.");
                 setFallbackImage(img, figcaption, description, seedSuffix, 'no-repl-key', phHeight);
                 return;
             }

             // Prepare the prompt: Use the description directly
             let prompt = description.replace(/<[^>]*>/g, '').replace(/\n/g, ' ').replace(/[^\p{L}\p{N}\s,'\-.]/gu, '').replace(/\s+/g, ' ').trim();
             if (!prompt) {
                 console.warn("Empty prompt after cleaning description.");
                 setFallbackImage(img, figcaption, description, seedSuffix, 'empty-prompt', phHeight);
                 return;
             }
             // Optionally shorten prompt if too long (Replicate might have limits)
             const MAX_PROMPT_LENGTH = 500; // Example limit
             if (prompt.length > MAX_PROMPT_LENGTH) {
                prompt = prompt.substring(0, MAX_PROMPT_LENGTH) + "...";
                console.warn("Prompt truncated to max length:", prompt);
             }

             const REPLICATE_API_URL = "https://api.replicate.com/v1/models/black-forest-labs/flux-1.1-pro/predictions";

             const requestBody = {
                 input: {
                     prompt: prompt,
                     prompt_upsampling: true // Or false for faster generation
                 }
             };

             try {
                 console.log(`Generating image via Replicate: "${prompt}"`);
                 const response = await fetch(REPLICATE_API_URL, {
                     method: 'POST',
                     headers: {
                         'Authorization': `Bearer ${REPLICATE_API_TOKEN}`,
                         'Content-Type': 'application/json',
                         'Prefer': 'wait' // Wait for the result synchronously
                     },
                     body: JSON.stringify(requestBody)
                 });

                 const responseData = await response.json();

                 if (!response.ok || responseData.status === 'failed') {
                     const errorDetail = responseData?.error || `HTTP Status: ${response.status}`;
                     console.error("Replicate API error:", errorDetail, responseData);
                     setFallbackImage(img, figcaption, description, seedSuffix, `repl-api-err-${response.status}`, phHeight);
                     return;
                 }

                 if (responseData.status === 'succeeded' && responseData.output && responseData.output.length > 0) {
                     const imageUrl = responseData.output[0]; // Get the first image URL
                     img.onload = () => { img.style.backgroundColor = 'transparent'; }
                     img.onerror = () => { setFallbackImage(img, figcaption, description, seedSuffix, 'repl-img-load-err', phHeight); }
                     img.src = imageUrl;
                     img.alt = prompt; // Use the prompt as alt text

                     // Add Replicate generation note (no user attribution available)
                     const sourceSpan = document.createElement('span');
                     sourceSpan.className = 'generation-source'; // Use specific class for styling
                     sourceSpan.textContent = getTranslatedText(null, 'generatedViaReplicate', false, 'Generated via Replicate');
                     figcaption.appendChild(sourceSpan);

                 } else {
                     console.warn("Replicate API did not return a successful output URL.", responseData);
                     setFallbackImage(img, figcaption, description, seedSuffix, 'repl-no-output', phHeight);
                 }

             } catch (error) {
                 console.error("Error fetching from Replicate API:", error);
                 setFallbackImage(img, figcaption, description, seedSuffix, 'repl-fetch-error', phHeight);
             }
        }

        function setFallbackImage(imgEl, figcaptionEl, desc, seed, reason, height) {
             const seedEnc = encodeURIComponent(desc.substring(0, 15) + seed + '-' + reason);
             const picSumH = Math.max(150, Math.round(height * 1.5)), picSumW = Math.round(picSumH * 1.6);
             imgEl.onload = () => { imgEl.style.backgroundColor = 'transparent'; }
             imgEl.onerror = () => { imgEl.style.backgroundColor = '#555'; imgEl.alt = `Fallback failed (Reason: ${reason})` }
             imgEl.src = `https://picsum.photos/seed/${seedEnc}/${picSumW}/${picSumH}`;
             imgEl.alt = `Placeholder: ${desc.substring(0, 50)}... (Reason: ${reason})`;
             const notice = document.createElement('span'); notice.className = 'fallback-notice';
             notice.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${reason})`;
             // Avoid adding duplicate notices
             if (!figcaptionEl.querySelector('.fallback-notice')) { figcaptionEl.appendChild(notice); }
             // Remove Replicate source if fallback is used
             const replicateSource = figcaptionEl.querySelector('.generation-source');
             if(replicateSource) replicateSource.remove();
        }

        // --- Color Swatch Creation ---
        function createColorSwatches(container, text) {
             if (!container) return false; container.innerHTML = ''; container.classList.remove('placeholder-notice');
             const colorRegex = /([\w\s\-\/()]+?)\s*\(?\s*(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})\s*\)?/gi;
             let match; let foundColors = false; let swatchIndex = 0;
             const potentialColors = text.split(/[,;\n]+/);
             potentialColors.forEach(part => {
                 colorRegex.lastIndex = 0;
                 while ((match = colorRegex.exec(part)) !== null) {
                     let name = match[1].trim().replace(/[():]/g, '').replace(/^-+|-+$/g, '').trim();
                     let hex = match[2].trim().toUpperCase();
                     if (!name || name.length < 2) continue;
                     if (hex.length === 4) hex = '#' + hex[1].repeat(2) + hex[2].repeat(2) + hex[3].repeat(2);
                     if (!/^#[0-9A-F]{6}$/.test(hex)) { console.warn(`Invalid hex: ${match[2]}`); continue; }
                     foundColors = true;
                     const swatch = document.createElement('div'); swatch.className = 'color-swatch';
                     try {
                         swatch.style.backgroundColor = hex;
                         swatch.style.color = isColorDarkGuess(hex) ? 'var(--text-primary)' : 'var(--bg-dark)';
                     } catch (e) { continue; }
                     const nameSpan = document.createElement('span'); nameSpan.textContent = name;
                     const hexSpan = document.createElement('span'); hexSpan.className = 'hex-code'; hexSpan.textContent = hex;
                     swatch.appendChild(nameSpan); swatch.appendChild(hexSpan); container.appendChild(swatch);
                     requestAnimationFrame(() => { setTimeout(() => { swatch.classList.add('visible'); }, 50 + swatchIndex * 70); });
                     swatchIndex++;
                 }
             });
             return foundColors;
        }

        // --- Color Lightness Guess ---
        function isColorDarkGuess(hexColor) {
            try {
                if (!hexColor?.startsWith('#')) return false; let hex = hexColor.substring(1);
                if (hex.length === 3) hex = hex[0].repeat(2) + hex[1].repeat(2) + hex[2].repeat(2);
                if (hex.length !== 6) return false;
                const r = parseInt(hex.substring(0, 2), 16), g = parseInt(hex.substring(2, 4), 16), b = parseInt(hex.substring(4, 6), 16);
                return (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255 < 0.5;
            } catch (e) { return false; }
        }

        // --- Utility Functions ---
        function clearResultsContent() {
             const contentAreas = resultsOutputArea.querySelectorAll('.card-content');
             if (!contentAreas.length) return;
             contentAreas.forEach(area => {
                 const sectionId = area.id;
                 const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId);
                 if (sectionTitle) { setPlaceholderForMissingSection(area, sectionTitle); }
                 else { // Fallback for unknown areas
                     area.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Cleared.')}</p>`;
                     area.classList.add('placeholder-notice');
                 }
             });
             resultsOutputArea.querySelectorAll('.result-card.visible, .color-swatch.visible').forEach(el => el.classList.remove('visible'));
             console.log("Cleared results content and added placeholders.");
         }
         function clearDetailedResultsContentOnly() {
             if (!detailedResultsGrid) return;
             detailedResultsGrid.querySelectorAll('.result-card').forEach(card => {
                 const contentArea = card.querySelector('.card-content'); if (!contentArea) return;
                 const sectionId = contentArea.id;
                 const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId);
                  if (sectionTitle) { setPlaceholderForMissingSection(contentArea, sectionTitle); }
                  else { contentArea.innerHTML = `<p class="placeholder-notice">${getTranslatedText(null, 'placeholderGeneric', false, 'Cleared.')}</p>`; contentArea.classList.add('placeholder-notice'); }
                  card.style.display = 'none'; card.classList.remove('visible');
             });
             console.log("Cleared detailed results content.");
         }
        function clearResultsAndErrors() {
             resultsOutputArea.style.display = 'none'; conceptCard.style.display = 'none';
             conceptCard.classList.remove('visible'); detailedResultsGrid.style.display = 'none';
             errorMessageDiv.style.display = 'none'; errorMessageDiv.textContent = '';
             errorMessageDiv.removeAttribute('data-error-key');
             clearResultsContent();
             if(exploreMoreButton) exploreMoreButton.disabled = true;
             if(regenerateButton) regenerateButton.disabled = true;
             console.log("Cleared results area and errors.");
        }
        function displayError(message, errorKey = 'errorUnknown') {
             message = String(message || getTranslatedText(null, errorKey, false, 'Unknown error.'));
             errorMessageDiv.textContent = message; errorMessageDiv.dataset.errorKey = errorKey;
             errorMessageDiv.style.display = 'block'; hideLoading();
             console.error("Displayed user error:", message, `(Key: ${errorKey})`);
             errorMessageDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        // --- Language Switching ---
        function formatDatasetKey(langCode, suffix = '') {
             let keyBase = (langCode === 'zh-CN') ? 'zhcn' : langCode.toLowerCase().split('-')[0];
             const capitalizedBase = keyBase.charAt(0).toUpperCase() + keyBase.slice(1);
             let key = 'lang' + capitalizedBase;
             if (suffix) {
                 let camelSuffix = suffix.replace(/[-_](.)/g, (_, c) => c.toUpperCase());
                 camelSuffix = camelSuffix.charAt(0).toUpperCase() + camelSuffix.slice(1);
                 key += camelSuffix;
             }
             return key.charAt(0).toLowerCase() + key.slice(1);
         }
         function getTranslatedText(element, suffixOrKey = '', isPlaceholderAttr = false, fallbackText = '') {
            // Try getting translation for specific key/suffix first
            let specificKey = '';
            if(suffixOrKey && element && element.dataset[`${formatDatasetKey(currentLang)}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`]){
                 specificKey = `${formatDatasetKey(currentLang)}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`;
            } else if(suffixOrKey && element && element.dataset[`${formatDatasetKey('en')}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`]) {
                 specificKey = `${formatDatasetKey('en')}${suffixOrKey.charAt(0).toUpperCase() + suffixOrKey.slice(1)}`;
            } else if (suffixOrKey) {
                 // Check for general data-lang-[lang] attribute if suffixOrKey might be a full key itself
                 specificKey = element?.dataset[formatDatasetKey(currentLang, suffixOrKey)] ? formatDatasetKey(currentLang, suffixOrKey) : formatDatasetKey('en', suffixOrKey);
            }

            // Try general data-lang-[lang] attribute if specific suffix key didn't work or wasn't provided
            let generalKey = formatDatasetKey(currentLang);
            let englishKey = formatDatasetKey('en');

            let translation = element?.dataset[specificKey] || // Try specific key first
                              element?.dataset[generalKey] ||   // Try general key for current lang
                              element?.dataset[englishKey] ||   // Try general key for English
                              fallbackText;                     // Use fallback

            // Final fallback check for specific element types if still no translation
            if (translation === fallbackText || translation === undefined || translation === '') {
                if (element && isPlaceholderAttr && element.hasAttribute('placeholder')) {
                    translation = element.getAttribute('placeholder');
                } else if (element && !isPlaceholderAttr && ['BUTTON', 'P', 'SMALL', 'LABEL', 'H1', 'H2', 'H3', 'LI', 'A', 'OPTION', 'TITLE', 'SPAN'].includes(element.tagName) && !element.children.length) {
                     // Be careful only to grab text content if it seems like a simple element
                    translation = element.textContent;
                }
            }

            // Specific override for Replicate source text
            if (suffixOrKey === 'generatedViaReplicate') {
                const translations = {
                    en: "Generated via Replicate",
                    es: "Generado vía Replicate",
                    vi: "Tạo bởi Replicate",
                    ja: "Replicate経由で生成",
                    zhcn: "通过 Replicate 生成"
                };
                return translations[currentLang] || translations['en'];
            }

            return String(translation ?? fallbackText).trim();
         }

        function updateLanguage(langCode) {
            currentLang = langCode; console.log(`Switching language to: ${langCode}`);
            document.documentElement.lang = langCode;
            allTranslatableElements.forEach(el => {
                const isPlaceholderTarget = (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') && el.hasAttribute('data-lang-en-placeholder');
                let primarySuffix = isPlaceholderTarget ? 'placeholder' : '';
                const fallbackKey = formatDatasetKey('en', primarySuffix);
                const fallbackValue = el.dataset[fallbackKey] || (isPlaceholderTarget ? el.getAttribute('placeholder') : el.textContent) || '';
                let translation = getTranslatedText(el, primarySuffix, isPlaceholderTarget, fallbackValue);

                if (isPlaceholderTarget) { el.placeholder = translation; }
                else if (el.tagName === 'TITLE') { document.title = translation; }
                else {
                    // Update simple text content elements carefully
                     const simpleTags = ['BUTTON', 'P', 'SMALL', 'LABEL', 'H1', 'H2', 'H3', 'LI', 'A', 'OPTION', 'SPAN'];
                     if (simpleTags.includes(el.tagName)) {
                         // Check if it only contains text or other translatable spans
                         let onlyTextOrTranslatableSpans = Array.from(el.childNodes).every(node =>
                             node.nodeType === Node.TEXT_NODE ||
                             (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN' && node.hasAttribute('data-lang-en')) ||
                             (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN' && !node.hasAttribute('data-lang-en')) // Allow plain spans (like icons)
                         );
                         // Avoid updating generated content inside cards, status text, or error messages here
                         if(onlyTextOrTranslatableSpans && !el.closest('.card-content') && el.id !== 'record-status-text' && el.id !== 'error-message') {
                            el.textContent = translation;
                         } else {
                              // console.warn("Skipping translation for complex element or generated content:", el);
                         }
                     }
                }
            });

            // Update dynamic/status elements using their stored keys
             if(recordAudioButton) updateRecordingUI(isRecording); // Updates button text based on state
             if(recordStatus?.dataset?.statusKey) {
                  let statusKey = recordStatus.dataset.statusKey, fallback = recordStatus.dataset.statusFallback || '';
                  let statusClass = Array.from(recordStatus.classList).find(c => ['complete', 'error', 'recording', 'transcribing'].includes(c)) || '';
                  let isPersistent = statusClass === 'complete' || statusClass === 'error';
                  // Use the key to re-translate the status message
                  updateRecordStatus(getTranslatedText(null, statusKey, false, fallback), statusClass, isPersistent, statusKey);
             } else if (!isRecording) { clearRecordStatus(); }
             if (loadingOverlay.classList.contains('show')) {
                 const loadingP = loadingOverlay.querySelector('p');
                 if(loadingP && loadingP.dataset.lastKey) {
                    loadingP.textContent = getTranslatedText(loadingP, loadingP.dataset.lastKey, false, 'Loading...');
                 }
             }
             if (errorMessageDiv.style.display === 'block' && errorMessageDiv.dataset.errorKey) {
                 errorMessageDiv.textContent = getTranslatedText(null, errorMessageDiv.dataset.errorKey, false, errorMessageDiv.textContent);
             }
             if (isSpeechRecognitionSupported) { // Update speech rec language
                 const bcp47Map = { 'zh-CN': 'zh-CN', 'vi': 'vi-VN', 'ja': 'ja-JP', 'es': 'es-ES' };
                 const newRecLang = bcp47Map[langCode] || (langCode.includes('-') ? langCode : `${langCode}-${langCode.toUpperCase()}`);
                 if (recognition && recognition.lang !== newRecLang) {
                      if (isRecording) { console.log("Stopping recording to change speech language..."); handleRecordButtonClick(); /* Call stop */ }
                      if(recognition) recognition.lang = newRecLang; console.log("Updated speech recognition language:", newRecLang);
                 }
            }

            // Re-apply placeholders and notes in results using current language
             if (resultsOutputArea.style.display === 'block') {
                 // Update general placeholders in empty cards
                 resultsOutputArea.querySelectorAll('.card-content.placeholder-notice').forEach(area => {
                     const sectionId = area.id; const sectionTitle = Object.keys(sections).find(key => sections[key] === sectionId);
                     if(sectionTitle) setPlaceholderForMissingSection(area, sectionTitle); // This function now uses getTranslatedText
                 });
                 // Update specific placeholders identified by data-placeholder-key within potentially complex structures
                 resultsOutputArea.querySelectorAll('[data-placeholder-key]').forEach(ph => {
                     // Check if it's *intended* to be a placeholder (e.g., inside a placeholder column or container)
                    const isTruePlaceholder = ph.classList.contains('placeholder-notice') || ph.closest('.placeholder-notice');
                     if (isTruePlaceholder) {
                         ph.textContent = getTranslatedText(null, ph.dataset.placeholderKey, false, ph.textContent);
                     }
                     // Special case for notes (always update)
                     if(ph.tagName === 'SMALL' && ph.dataset.placeholderKey && ph.dataset.placeholderKey.endsWith('NotePlaceholder')) {
                         ph.textContent = getTranslatedText(null, ph.dataset.placeholderKey, false, ph.textContent);
                     }
                 });
                  // Retranslate budget column titles if they are placeholders
                 const budgetCard = document.getElementById('result-budget-card');
                 if (budgetCard && budgetCard.style.display === 'flex') {
                     budgetCard.querySelectorAll('.budget-column.placeholder-notice h3').forEach(h3 => {
                         const levelMatch = h3.textContent.match(/^(Low|Mid|High)/i);
                         if (levelMatch) {
                             const levelKey = levelMatch[1];
                             h3.textContent = getTranslatedText(null, `budget${levelKey}Title`, false, `${levelKey} Budget`);
                         }
                     });
                      // Retranslate placeholder text inside budget columns
                     budgetCard.querySelectorAll('.budget-column.placeholder-notice p[data-placeholder-key="budgetDetailsMissing"]').forEach(p => {
                         p.textContent = `(${getTranslatedText(null, 'budgetDetailsMissing', false, `Details missing.`)})`;
                     });
                 }
                 // Retranslate image generation source notes
                 resultsOutputArea.querySelectorAll('.image-placeholder figcaption .generation-source').forEach(span => {
                    span.textContent = getTranslatedText(null, 'generatedViaReplicate', false, 'Generated via Replicate');
                 });
                 // Retranslate fallback notices
                 resultsOutputArea.querySelectorAll('.image-placeholder figcaption .fallback-notice').forEach(span => {
                    const reasonMatch = span.textContent.match(/\(([^:]+):\s*(.*)\)/); // Extract reason part
                    if (reasonMatch) {
                         const reasonText = reasonMatch[2] || 'unknown';
                         span.textContent = `(${getTranslatedText(null, 'placeholderReason', false, 'Placeholder')}: ${reasonText})`;
                    }
                 });
             }
             console.log("Language update complete:", langCode);
        }
        function saveLanguagePreference(langCode) { try { localStorage.setItem('mvGeneratorLang', langCode); } catch (e) {} }
        function loadLanguagePreference() {
            try { const saved = localStorage.getItem('mvGeneratorLang'); if (saved && Array.from(languageSelect.options).some(o => o.value === saved)) { languageSelect.value = saved; return saved; } } catch (e) {}
            return languageSelect ? languageSelect.value : 'en';
        }

        // --- Event Listeners Setup ---
        navLinks.forEach(link => { link.addEventListener('click', (e) => { const page = link.getAttribute('data-page'); if (page) { e.preventDefault(); showPage(page); } }); });
        if (exploreButton) { exploreButton.addEventListener('click', () => showPage('feature')); }
        backButtons.forEach(button => { button.addEventListener('click', (e) => { e.preventDefault(); showPage('home'); }); });
        if (generateConceptButton) { generateConceptButton.addEventListener('click', handleGenerateConcept); }
        if (exploreMoreButton) { exploreMoreButton.addEventListener('click', handleExploreMore); }
        if (regenerateButton) { regenerateButton.addEventListener('click', handleRegenerateConcept); }
        if (languageSelect) { languageSelect.addEventListener('change', (e) => { updateLanguage(e.target.value); saveLanguagePreference(e.target.value); }); }

        // --- Initial Setup ---
        const initialLang = loadLanguagePreference(); updateLanguage(initialLang);
        showPage('home'); clearResultsAndErrors();
        console.log("MV Generator Initialized. Lang:", currentLang, "Speech Support:", isSpeechRecognitionSupported);
        // Initial check for audio support display
        if(recordAudioButton && recordAudioButton.disabled && (!navigator.mediaDevices?.getUserMedia || !isSpeechRecognitionSupported)) {
           const errorKey = !navigator.mediaDevices?.getUserMedia ? 'statusAudioNotSupported' : 'statusSpeechRecNotSupported';
           const errorMsg = getTranslatedText(null, errorKey, false, 'Audio/Speech input not supported.');
           updateRecordStatus(errorMsg, 'error', true, errorKey);
        }

    }); // End DOMContentLoaded
    </script>
    <!-- ========= END JAVASCRIPT ========= -->

</body>
</html>
