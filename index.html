<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Title will be updated by JS -->
    <title data-lang-en="MV Suggestion Tool" data-lang-es="Herramienta de Sugerencias MV">MV Suggestion Tool</title>
    <style>
        /* Basic Reset & Defaults */
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa; /* Lighter background */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        main {
            flex-grow: 1; /* Pushes footer elements down */
            padding-top: 80px; /* Increased padding for taller nav */
            width: 100%;
        }

        /* --- LOADING OVERLAY --- */
        #loading-overlay {
            position: fixed;
            inset: 0; /* top, right, bottom, left = 0 */
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(3px);
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            z-index: 9999; /* Highest */
            flex-direction: column; /* Stack text and spinner */
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #loading-overlay.show {
            display: flex;
            opacity: 1;
        }
        #loading-overlay p {
            font-weight: 500;
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
            /* Add data attributes for translation */
            data-lang-en="Generating creative suggestions..."
            data-lang-es="Generando sugerencias creativas..."
        }
        .loading-spinner { /* Renamed from just 'spinner' */
            border: 5px solid rgba(0, 0, 0, 0.1);
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border-left-color: #6E91D6;
            margin: 0 auto;
            animation: spin 1s linear infinite;
        }
        /* --- END LOADING OVERLAY --- */


        /* Navigation */
        .main-nav {
            background-color: rgba(51, 51, 51, 0.9); /* Slightly transparent dark */
            backdrop-filter: blur(5px); /* Blur effect for nav background */
            color: #fff;
            position: fixed; /* Keeps nav on top */
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            display: flex;
            justify-content: space-between; /* Space between logo and menu */
            align-items: center;
            padding: 10px 25px; /* Padding around nav */
            height: 70px; /* Fixed height */
            gap: 15px; /* Add gap between items */
        }

        .logo-placeholder {
            max-width: 120px;
            max-height: 50px;
            object-fit: contain;
            user-select: none;
            /* Basic styling if image fails to load */
            color: white;
            text-align: center;
            line-height: 50px; /* Center text vertically */
            font-size: 0.8em;
            font-weight: bold;
            overflow: hidden;
            flex-shrink: 0; /* Prevent logo from shrinking */
        }


        .main-nav ul {
            list-style: none;
            display: flex;
            align-items: center;
            /* Removed justify-content: flex-end; flex-grow handles spacing */
            flex-grow: 1; /* Allow menu to take available space */
        }

        .main-nav ul li {
            margin-left: 30px;
        }

        .main-nav ul li a {
            color: #fff;
            text-decoration: none;
            padding: 8px 12px;
            font-size: 1.05em;
            border-radius: 4px;
            transition: color 0.3s ease, background-color 0.3s ease, border-bottom 0.3s ease;
            border-bottom: 3px solid transparent;
            cursor: pointer;
        }

        .main-nav ul li a:hover,
        .main-nav ul li a.active {
            color: #e0cff0;
            border-bottom: 3px solid #9E69AF;
            background-color: rgba(255, 255, 255, 0.1);
        }

        /* --- Settings Box (Language) --- */
        #settings-box {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto; /* Push to the right */
            flex-shrink: 0; /* Prevent shrinking */
        }
        #settings-box label {
            font-size: 0.9em;
            color: #eee;
            /* Add data attributes */
            data-lang-en="Language:"
            data-lang-es="Idioma:"
        }
        #settings-box select {
            padding: 5px 8px;
            border-radius: 4px;
            border: 1px solid #777;
            background-color: #555;
            color: #fff;
            font-size: 0.9em;
            cursor: pointer;
        }
        #settings-box select:focus {
            outline: 1px solid #9E69AF;
        }
        /* --- End Settings Box --- */


        /* Page Sections */
        .page {
            display: none;
            padding: 30px 20px;
            animation: fadeIn 0.6s ease-in-out;
            min-height: calc(100vh - 110px); /* Adjust based on footer height if added */
            position: relative;
            padding-bottom: 80px; /* Space for back button */
        }

        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .content-container {
            max-width: 950px;
            margin: 20px auto;
            background-color: #fff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        }

        /* Headings */
        h1, h2 {
            color: #343a40;
            margin-bottom: 20px;
            font-weight: 600;
        }
         h3 { /* Added for budget columns */
             color: #495057;
             margin-bottom: 10px;
             font-size: 1.15em;
             font-weight: 600;
         }

        h1 {
            text-align: center;
            font-size: 2.4em;
            color: #495057;
        }

        h2 {
            font-size: 1.9em;
            border-bottom: 2px solid #eee;
            padding-bottom: 8px;
            margin-top: 35px;
            color: #6E91D6;
        }
        .result-section h2 {
             color: #9E69AF;
             border-color: #e0d1e6;
        }


        /* Button General Styling & Gradient */
        .btn {
            display: inline-block;
            padding: 14px 28px;
            margin: 10px 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.05em;
            font-weight: 600;
            text-align: center;
            text-decoration: none;
            color: #fff;
            background: linear-gradient(135deg, #9E69AF, #6E91D6);
            background-size: 200% 200%;
            transition: background-position 0.4s ease-out, transform 0.15s ease, box-shadow 0.3s ease, opacity 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }

        /* Button Hover Animation */
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .btn:hover:not(:disabled) {
            animation: gradientShift 4s ease infinite;
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(138, 105, 175, 0.4);
        }

        .btn:active:not(:disabled) {
            transform: scale(0.97) translateY(0);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #ccc; /* Simple disabled background */
            box-shadow: none;
        }


        /* Specific Button Styles */
         .btn-primary { /* Explore Now & Get Suggestions */ }
         .btn-secondary { /* Go Back, Explore More, Re-Generate */
             background: linear-gradient(135deg, #6c757d, #495057);
             background-size: 200% 200%;
         }
          .btn-secondary:hover:not(:disabled) { box-shadow: 0 4px 10px rgba(80, 80, 80, 0.3); }
         .btn-warning { /* Record */
             background: linear-gradient(135deg, #ffc107, #ff9800);
             background-size: 200% 200%;
             color: #333;
         }
         .btn-warning:hover:not(:disabled) { box-shadow: 0 4px 10px rgba(255, 170, 0, 0.4); color: #111; }
         .btn-danger { /* Stop Recording */
             background: linear-gradient(135deg, #dc3545, #c82333);
             background-size: 200% 200%;
         }
         .btn-danger:hover:not(:disabled) { box-shadow: 0 4px 10px rgba(220, 50, 70, 0.4); }


        .btn-back {
            position: absolute;
            bottom: 20px;
            left: 25px;
            margin: 0;
            z-index: 10;
        }
        #home-page .btn-back { display: none; }


        /* Home Page Specific & Parallax Setup */
        .hero-container {
            position: relative;
            width: 100%;
            height: 65vh; /* Adjust as needed */
            min-height: 450px;
            max-height: 700px;
            overflow: hidden; /* Crucial for parallax */
            border-radius: 10px;
            margin: 0 auto 30px auto;
             /* Basic styling if image fails to load */
            background-color: #ddd;
        }

        .hero-image {
            position: absolute; /* Needed for transform control */
            left: 0;
            top: 0; /* Adjust if using scale */
            width: 100%;
            height: 100%; /* Start at 100%, scale can make it bigger */
            object-fit: cover;
            display: block;
            filter: blur(4px) brightness(0.9);
            /* Scale slightly larger to prevent edges showing during parallax movement */
            transform: scale(1.1); /* Base scale */
            /* transform: translateY will be updated by JS */
            will-change: transform; /* Hint for browser optimization */
            transition: transform 0.1s linear; /* Slight smoothing for JS updates */
        }

        .hero-text-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 40px 50px;
            border-radius: 8px;
            text-align: center;
            max-width: 85%;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 1; /* Ensure text is above image */
        }

        .hero-text-overlay h1 {
            font-size: 2.8em;
            margin-bottom: 25px;
            color: #fff;
            border: none;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            /* Add data attributes */
            data-lang-en="Get your MV suggestion based on your lyrics!"
            data-lang-es="¡Obtén sugerencias para tu MV basadas en tus letras!"
        }

        /* About Page Specific */
        #about-page p {
            max-width: 750px;
            margin: 30px auto;
            text-align: justify;
            font-size: 1.1em;
            color: #495057;
            /* Add data attributes */
            data-lang-en="Welcome to the MV Assistant! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, and genre, MV Assistant generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, and color palettes. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!"
            data-lang-es="¡Bienvenido al Asistente de MV! Nos apasiona ayudar a los artistas a traducir sus creaciones musicales en historias visuales convincentes. Crear el concepto perfecto para un video musical puede ser desafiante, requiriendo una mezcla de visión artística y planificación práctica. Nuestra herramienta impulsada por IA está diseñada para cerrar esa brecha. Al analizar tus letras, palabras clave y género, el Asistente de MV genera sugerencias personalizadas para conceptos de videos musicales, requisitos, estimaciones de presupuesto, inspiraciones visuales y paletas de colores. Nuestro objetivo es agilizar el proceso creativo, proporcionando una plataforma de lanzamiento para tus ideas y empoderándote para dar vida visual a tu música, ya seas un artista independiente o parte de una producción más grande. ¡Hagamos algo increíble juntos!"
        }

        /* Feature Page Specific */
        #feature-form { margin-top: 30px; }
        .form-group { margin-bottom: 30px; }
        .form-group label { display: block; margin-bottom: 10px; font-weight: 600; color: #495057; font-size: 1.05em; }
        .form-group input[type="text"], .form-group textarea, .form-group select, .form-group input[type="file"] {
            width: 100%; padding: 14px; border: 1px solid #ced4da; border-radius: 6px; font-size: 1em; margin-bottom: 5px; transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
             border-color: #8a6fb5; box-shadow: 0 0 0 3px rgba(158, 105, 175, 0.2); outline: none;
        }
        .form-group textarea { resize: vertical; min-height: 120px; }
         .form-group select {
            appearance: none; -webkit-appearance: none; -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%236c757d" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat; background-position: right 12px center; background-size: 20px; padding-right: 45px; cursor: pointer;
         }
         .form-group select option[disabled] { color: #999; }

        /* Audio Input Group Styling */
        .audio-input-group { display: flex; align-items: center; flex-wrap: wrap; gap: 10px; }
        .form-group input[type="file"] { padding: 8px 12px; cursor: pointer; flex-grow: 1; min-width: 200px; margin-bottom: 0; }
        input[type="file"]::file-selector-button { padding: 10px 18px; margin-right: 12px; border: none; border-radius: 5px; background: linear-gradient(135deg, #6c757d, #495057); color: #fff; cursor: pointer; transition: background 0.3s ease, transform 0.1s ease; font-weight: 600; }
        input[type="file"]::file-selector-button:hover { transform: scale(1.03); }
         input[type="file"]::file-selector-button:active { transform: scale(0.98); }
        .optional-notice { margin-left: 5px; font-size: 0.9em; color: #6c757d; font-style: italic; vertical-align: middle; }

        #record-status { margin-left: 15px; font-style: italic; font-weight: 500; display: inline-flex; align-items: center; min-height: 24px; }
        #record-status.recording { color: #dc3545; }
        #record-status.transcribing { color: #007bff; }
        #record-status.complete { color: #28a745; }
        #record-status.error { color: #dc3545; }

        /* Recording Animation Styles */
        .recording-dots { display: inline-block; vertical-align: middle; margin-right: 6px; }
        .recording-dots span { display: inline-block; width: 8px; height: 8px; margin-left: 3px; border-radius: 50%; background-color: #dc3545; animation: blink 1.4s infinite both; }
        .recording-dots span:nth-child(1) { animation-delay: 0s; }
        .recording-dots span:nth-child(2) { animation-delay: 0.2s; }
        .recording-dots span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes blink { 0%, 80%, 100% { opacity: 0; } 40% { opacity: 1; } }

         /* Transcript output area */
        #transcript-group { display: none; margin-top: 20px; }
        #transcript-output { background-color: #e9ecef; font-style: italic; color: #495057; min-height: 80px; cursor: default; }
        .form-group small { display: block; margin-top: 8px; color: #6c757d; font-size: 0.9em; }
        #generate-concept-button { display: block; width: 100%; max-width: 350px; margin: 40px auto 0 auto; padding: 16px 30px; font-size: 1.15em; }

        /* Concept & Detailed Results Areas */
        #initial-concept-area {
            margin-top: 50px;
            padding-top: 30px;
            border-top: 2px solid #eee;
            display: none; /* Initially hidden */
            text-align: center; /* Center buttons */
        }
        #detailed-results-area {
            margin-top: 30px; /* Space between initial concept and details */
            padding-top: 30px;
            border-top: 1px dashed #ccc; /* Separator */
            display: none; /* Initially hidden */
        }

        #initial-concept-area .result-section {
             margin-bottom: 20px;
             text-align: left; /* Reset text align for the section itself */
        }
        #explore-more-button, #regenerate-button {
            margin: 15px 10px; /* Spacing for new buttons */
        }

        /* Result Sections (shared styles) */
        .result-section {
            background-color: #ffffff;
            padding: 25px 30px;
            margin-bottom: 25px;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
            /* display: block; Will be controlled by parent */
        }

        /* General content styling */
        .result-section .content { font-size: 1em; color: #495057; line-height: 1.7; }
        #result-concept .content p { white-space: pre-wrap; }

        /* List styling (Requirements) */
        #result-requirements .content ul { margin-left: 0; margin-top: 10px; margin-bottom: 10px; padding-left: 0; list-style: none; }
         #result-requirements li { margin-bottom: 10px; padding-left: 25px; position: relative; }
         #result-requirements li::before { content: '▹'; color: #6E91D6; font-size: 1.2em; position: absolute; left: 0; top: -2px; }

        /* --- Budget Column Styles --- */
        .budget-columns-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Create 3 equal columns */
            gap: 25px; /* Space between columns */
            margin-top: 15px;
        }
        .budget-column {
            border: 1px solid #eee;
            padding: 20px;
            border-radius: 6px;
            background-color: #fdfdff; /* Slightly off-white */
        }
        .budget-column h3 {
            margin-top: 0;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            color: #6E91D6; /* Match section header color */
            font-size: 1.2em;
        }
        .budget-column p {
            font-size: 0.95em;
            line-height: 1.6;
            color: #495057;
            white-space: pre-wrap; /* Allow wrapping for budget description & potential line breaks */
        }
        .budget-column p strong { /* Style potential bolded costs */
            font-weight: 600;
            color: #333;
        }

        /* Image Placeholder Styles */
        .image-placeholder-container { display: grid; gap: 20px; margin-top: 15px; }
        /* Grid definitions adjusted based on expected content */
        #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); } /* Fits 3 well on most screens */
        #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); } /* Fits 5 well */

        .image-placeholder { border: 1px solid #dee2e6; border-radius: 6px; background-color: #f8f9fa; overflow: hidden; text-align: center; color: #495057; box-shadow: 0 1px 4px rgba(0,0,0,0.05); transition: transform 0.3s ease, box-shadow 0.3s ease; position: relative; }
        .image-placeholder:hover { transform: translateY(-3px); box-shadow: 0 4px 10px rgba(0,0,0,0.08); }
        .image-placeholder img { display: block; width: 100%; object-fit: cover; background-color: #e9ecef; border-bottom: 1px solid #dee2e6; }
        /* Adjusted heights based on container */
        #result-visuals .image-placeholder img { height: 180px; }
        #result-moodboard .image-placeholder img { height: 140px; }

        .image-placeholder figcaption { font-size: 0.9em; padding: 10px 12px 15px 12px; background-color: #fff; min-height: 50px; line-height: 1.4; }
        /* Style attribution link */
        .image-placeholder figcaption a { font-size: 0.75em; display: block; margin-top: 5px; color: #6c757d; text-decoration: none; transition: color 0.2s ease; }
        .image-placeholder figcaption a:hover { color: #495057; }
        .image-placeholder figcaption .fallback-notice { font-size: 0.75em; display: block; margin-top: 3px; color: #888; font-style: italic; }

        /* Specific Small Notes */
        .result-section small { display: block; margin-top: 15px; color: #6c757d; font-style: italic; font-size: 0.85em; }

        /* Color Palette Display */
        .color-palette-display { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 15px; }
        .color-swatch { min-width: 110px; height: 80px; border-radius: 6px; border: 1px solid rgba(0, 0, 0, 0.1); display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 0.9em; font-weight: 600; text-align: center; overflow: hidden; padding: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); transition: transform 0.2s ease; flex-grow: 1; }
        .color-swatch:hover { transform: scale(1.05); }
        .color-swatch span { display: block; word-break: break-word; max-width: 100%; }
        .color-swatch .hex-code { margin-top: 8px; font-size: 1em; font-family: 'Courier New', Courier, monospace; user-select: all; opacity: 0.85; }

        /* Placeholder for Inline Loading (Not Used with Overlay) */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Error Message */
        .error-message { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; padding: 18px 25px; border-radius: 6px; margin: 25px 0; text-align: center; font-weight: 500; display: none; }

        /* --- Responsive Adjustments --- */
        @media (max-width: 992px) {
             .content-container { max-width: 90%; padding: 30px; }
             h1 { font-size: 2.1em; } h2 { font-size: 1.7em; }
             .hero-text-overlay h1 { font-size: 2.4em; }
             #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }
             #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); } /* Adjusted for 5 items */
             #result-visuals .image-placeholder img { height: 160px; }
             #result-moodboard .image-placeholder img { height: 130px; }
             /* Budget columns stack on medium screens */
             .budget-columns-container { grid-template-columns: 1fr; }
             /* Adjust nav layout for settings box */
            #settings-box { margin-left: 15px; /* Add some space from menu */ }
        }

        @media (max-width: 768px) {
            .main-nav { padding: 10px 15px; height: auto; flex-direction: column; align-items: stretch; }
            .logo-placeholder { margin-bottom: 10px; width: 100px; height: auto; align-self: flex-start; }
            .main-nav ul { justify-content: flex-start; width: 100%; padding-top: 10px; flex-wrap: wrap; }
             .main-nav ul li { margin-left: 0; margin-right: 15px; margin-bottom: 5px; }
             .main-nav ul li a { padding: 6px 10px; font-size: 1em; }
            /* Settings box below menu on small screens */
            #settings-box { order: 3; /* Place it after the menu */ width: 100%; margin-left: 0; margin-top: 10px; justify-content: flex-start; }
            main { padding-top: 170px; } /* Increased padding for taller nav */

            .hero-container { height: 55vh; min-height: 400px; }
            .hero-text-overlay { padding: 30px; }
            .hero-text-overlay h1 { font-size: 2em; }
            h1 { font-size: 1.9em; } h2 { font-size: 1.6em; }
            .content-container { padding: 25px; }

            #result-visuals .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); }
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); } /* Adjusted for 5 items */
            #result-visuals .image-placeholder img { height: 150px; }
            #result-moodboard .image-placeholder img { height: 120px; }

            .btn-back { position: relative; bottom: auto; left: auto; margin: 30px auto 0 auto; display: block; width: fit-content; }
             #home-page .btn-back { display: none; }
            .page { padding-bottom: 30px; padding-left: 15px; padding-right: 15px; }
             .budget-columns-container { gap: 15px; } /* Reduce gap on smaller screens */
             .budget-column { padding: 15px; }
             /* Parallax disabled via JS on screens < 768px */
        }

        @media (max-width: 480px) {
            main { padding-top: 160px; } /* Adjusted */
            .hero-container { height: 50vh; min-height: 350px; }
            .hero-text-overlay { padding: 25px; max-width: 90%; }
            .hero-text-overlay h1 { font-size: 1.7em; }
            .btn { padding: 12px 22px; font-size: 1em; margin: 8px 5px;}
            #generate-concept-button { max-width: 90%; padding: 14px 25px; font-size: 1.1em; }
            .form-group input[type="text"], .form-group textarea, .form-group select { padding: 12px; }
            .audio-input-group { flex-direction: column; align-items: stretch; }
            .form-group input[type="file"] { margin-bottom: 10px; }
             .audio-input-group .btn { width: 100%; margin: 5px 0;}
             #record-status { margin: 5px 0 10px 0; text-align: center; }
            #result-visuals .image-placeholder-container { grid-template-columns: 1fr; } /* Single column */
            #result-moodboard .image-placeholder-container { grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); } /* Adjusted for 5 items */
            #result-visuals .image-placeholder img { height: 160px; } /* Adjust height for single column */
            #result-moodboard .image-placeholder img { height: 110px; }
            .content-container { padding: 20px; }
             .result-section { padding: 20px; }
             h1 { font-size: 1.7em; } h2 { font-size: 1.5em; }
            .optional-notice { margin-left: 0; margin-top: 5px; display: block; text-align: center; }
            #record-status { margin-left: 0; justify-content: center; width: 100%; margin-top: 5px; }
             #settings-box select, #settings-box label { font-size: 0.95em; } /* Slightly larger on smallest screens */
             /* Stack explore/regenerate buttons */
             #explore-more-button, #regenerate-button { display: block; width: 80%; margin: 10px auto; }
        }

    </style>
</head>
<body>

    <!-- Loading Overlay Div -->
    <div id="loading-overlay">
        <p data-lang-en="Generating creative suggestions..." data-lang-es="Generando sugerencias creativas...">Generating creative suggestions...</p>
        <div class="loading-spinner"></div>
    </div>

    <nav class="main-nav">
        <img src="logofinal(white).png" alt="MV Assistant Logo" class="logo-placeholder" onerror="this.alt='Logo'; this.style.backgroundColor='#555'; this.style.color='white'; this.src=''; this.style.display='inline-block';">
        <ul>
            <li><a data-page="home" class="nav-link active" data-lang-en="Home" data-lang-es="Inicio">Home</a></li>
            <li><a data-page="about" class="nav-link" data-lang-en="About" data-lang-es="Acerca de">About</a></li>
            <li><a data-page="feature" class="nav-link" data-lang-en="Feature" data-lang-es="Función">Feature</a></li>
        </ul>
        <!-- Settings Box for Language -->
        <div id="settings-box">
            <label for="language-select" data-lang-en="Language:" data-lang-es="Idioma:">Language:</label>
            <select id="language-select">
                <option value="en">English</option>
                <option value="es">Español (Spanish)</option>
                <option value="fr">Français (French)</option>
                <option value="de">Deutsch (German)</option>
                <option value="zh-CN">简体中文 (Chinese Simp.)</option>
                <option value="ja">日本語 (Japanese)</option>
                <option value="pt">Português (Portuguese)</option>
                <option value="ru">Русский (Russian)</option>
                <option value="hi">हिन्दी (Hindi)</option>
                <option value="ar">العربية (Arabic)</option>
                <!-- Add more languages as needed -->
            </select>
        </div>
    </nav>

    <main>
        <!-- Home Page Section -->
        <section id="home-page" class="page active">
            <div class="hero-container">
                <img src="heroimg.jpg" alt="Abstract music visuals" class="hero-image" onerror="this.style.display='none'; this.parentElement.style.backgroundColor='#ccc';">
                <div class="hero-text-overlay">
                    <h1 data-lang-en="Get your MV suggestion based on your lyrics!" data-lang-es="¡Obtén sugerencias para tu MV basadas en tus letras!">Get your MV suggestion based on your lyrics!</h1>
                    <button id="explore-button" class="btn btn-primary" data-lang-en="Explore now" data-lang-es="Explorar ahora">Explore now</button>
                </div>
            </div>
        </section>

        <!-- About Page Section -->
        <section id="about-page" class="page">
            <div class="content-container">
                <h2 data-lang-en="About Us" data-lang-es="Acerca de Nosotros">About Us</h2>
                <p data-lang-en="Welcome to the MV Assistant! We are passionate about helping artists translate their musical creations into compelling visual stories. Crafting the perfect music video concept can be challenging, requiring a blend of artistic vision and practical planning. Our AI-powered tool is designed to bridge that gap. By analyzing your lyrics, keywords, and genre, MV Assistant generates tailored suggestions for music video concepts, requirements, budget estimations, visual inspirations, and color palettes. We aim to streamline the creative process, providing a launchpad for your ideas and empowering you to bring your music to life visually, whether you're an indie artist or part of a larger production. Let's make something amazing together!"
                   data-lang-es="¡Bienvenido al Asistente de MV! Nos apasiona ayudar a los artistas a traducir sus creaciones musicales en historias visuales convincentes. Crear el concepto perfecto para un video musical puede ser desafiante, requiriendo una mezcla de visión artística y planificación práctica. Nuestra herramienta impulsada por IA está diseñada para cerrar esa brecha. Al analizar tus letras, palabras clave y género, el Asistente de MV genera sugerencias personalizadas para conceptos de videos musicales, requisitos, estimaciones de presupuesto, inspiraciones visuales y paletas de colores. Nuestro objetivo es agilizar el proceso creativo, proporcionando una plataforma de lanzamiento para tus ideas y empoderándote para dar vida visual a tu música, ya seas un artista independiente o parte de una producción más grande. ¡Hagamos algo increíble juntos!">
                    Welcome to the MV Assistant! ... Let's make something amazing together!
                </p>
            </div>
            <button class="btn btn-secondary btn-back" data-target="home" data-lang-en="Go Back" data-lang-es="Volver">Go Back</button>
        </section>

        <!-- Feature Page Section -->
        <section id="feature-page" class="page">
            <div class="content-container">
                <h1 data-lang-en="MV Assistant" data-lang-es="Asistente de MV">MV Assistant</h1>

                <form id="feature-form" onsubmit="return false;">
                    <div class="form-group">
                        <label for="lyrics-input" data-lang-en="Music Lyrics:" data-lang-es="Letra de la Música:">Music Lyrics:</label>
                        <textarea id="lyrics-input" rows="7" data-lang-en-placeholder="Paste your complete song lyrics here..." data-lang-es-placeholder="Pega la letra completa de tu canción aquí..." placeholder="Paste your complete song lyrics here..." required></textarea>
                    </div>
                    <div class="form-group">
                        <label for="keywords-input" data-lang-en="Keywords / Theme:" data-lang-es="Palabras Clave / Tema:">Keywords / Theme:</label>
                        <input type="text" id="keywords-input" data-lang-en-placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle, first love" data-lang-es-placeholder="ej., nostálgico, ambiente de verano, decadencia urbana, superación, primer amor" placeholder="e.g., nostalgic, summer vibe, urban decay, overcoming struggle, first love" required>
                    </div>
                    <div class="form-group">
                        <label for="genre-select" data-lang-en="Music Genre:" data-lang-es="Género Musical:">Music Genre:</label>
                        <select id="genre-select" required>
                            <option value="" disabled selected data-lang-en="-- Select a Genre --" data-lang-es="-- Selecciona un Género --">-- Select a Genre --</option>
                            <option value="RnB">RnB / Soul</option>
                            <option value="Folk">Folk / Acoustic</option>
                            <option value="Rock">Rock (Alternative, Hard Rock, etc.)</option>
                            <option value="Pop">Pop (Synth-pop, Dance-pop, etc.)</option>
                            <option value="Hiphop">Hip-hop / Rap</option>
                            <option value="Electronic">Electronic (EDM, House, Techno)</option>
                            <option value="Classical">Classical / Orchestral</option>
                            <option value="Country">Country</option>
                             <option value="Jazz">Jazz / Blues</option>
                             <option value="Reggae">Reggae / Dancehall</option>
                             <option value="Metal">Metal</option>
                            <option value="Other">Other / Fusion</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="track-upload" data-lang-en="Track Input (Optional):" data-lang-es="Entrada de Pista (Opcional):">Track Input (Optional):</label>
                        <div class="audio-input-group">
                             <input type="file" id="track-upload" accept="audio/*">
                             <button type="button" id="record-audio-button" class="btn btn-warning" data-lang-en="Record Audio" data-lang-es="Grabar Audio">Record Audio</button>
                             <span class="optional-notice" data-lang-en="(Optional)" data-lang-es="(Opcional)">(Optional)</span>
                             <span id="record-status" class="record-status-base">
                                 <span id="recording-animation" class="recording-dots" style="display: none;"><span></span><span></span><span></span></span>
                                 <span id="record-status-text"></span>
                             </span>
                        </div>
                        <small data-lang-en="Note: Audio analysis (upload/record) requires browser support for recording & speech recognition. Suggestions are primarily based on text inputs + transcript."
                               data-lang-es="Nota: El análisis de audio (carga/grabación) requiere soporte del navegador para grabación y reconocimiento de voz. Las sugerencias se basan principalmente en entradas de texto + transcripción.">
                            Note: Audio analysis (upload/record) requires browser support...
                        </small>
                    </div>
                    <div class="form-group" id="transcript-group" style="display: none;">
                        <label for="transcript-output" data-lang-en="Singing Transcript (from recording):" data-lang-es="Transcripción del Canto (de grabación):">Singing Transcript (from recording):</label>
                        <textarea id="transcript-output" rows="4" readonly data-lang-en-placeholder="Transcript will appear here after recording..." data-lang-es-placeholder="La transcripción aparecerá aquí después de grabar..." placeholder="Transcript will appear here after recording..."></textarea>
                        <small data-lang-en="This text will be analyzed along with lyrics." data-lang-es="Este texto se analizará junto con la letra.">This text will be analyzed along with lyrics.</small>
                    </div>

                    <!-- UPDATED BUTTON -->
                    <button type="button" id="generate-concept-button" class="btn btn-primary" data-lang-en="Generate Concept" data-lang-es="Generar Concepto">Generate Concept</button>
                </form>

                <div id="error-message" class="error-message"></div>

                <!-- Area for Initial Concept and Action Buttons -->
                <div id="initial-concept-area" style="display: none;">
                    <section id="result-concept" class="result-section">
                         <!-- Add data attributes -->
                         <h2 data-lang-en="Concept / Key Visual" data-lang-es="Concepto / Visual Clave">Concept / Key Visual</h2>
                         <div class="content"><p></p></div>
                    </section>
                    <button id="explore-more-button" class="btn btn-secondary" data-lang-en="Explore More" data-lang-es="Explorar Más">Explore More</button>
                    <button id="regenerate-button" class="btn btn-secondary" data-lang-en="Re-Generate Concept" data-lang-es="Re-Generar Concepto">Re-Generate Concept</button>
                </div>

                <!-- Area for Detailed Results (shown after "Explore More") -->
                <div id="detailed-results-area" style="display: none;">
                     <section id="result-requirements" class="result-section">
                          <!-- Add data attributes -->
                         <h2 data-lang-en="Requirements for MV" data-lang-es="Requisitos para el MV">Requirements for MV</h2>
                         <div class="content"><ul></ul></div>
                     </section>
                     <section id="result-budget" class="result-section">
                          <!-- Add data attributes -->
                         <h2 data-lang-en="Estimated Budget" data-lang-es="Presupuesto Estimado">Estimated Budget</h2>
                         <div class="content"><div class="budget-columns-container"></div></div>
                     </section>
                     <section id="result-visuals" class="result-section">
                           <!-- Add data attributes -->
                         <h2 data-lang-en="Visual Demo (Key Image Ideas)" data-lang-es="Demo Visual (Ideas de Imágenes Clave)">Visual Demo (Key Image Ideas)</h2>
                         <div class="content">
                             <div class="image-placeholder-container"></div>
                         </div>
                         <!-- Add data attributes -->
                         <small data-lang-en="Note: Images are illustrative examples fetched based on AI descriptions. Actual MV visuals require specific direction."
                                data-lang-es="Nota: Las imágenes son ejemplos ilustrativos obtenidos según las descripciones de la IA. Los visuales reales del MV requieren dirección específica.">
                                Note: Images are illustrative examples...
                          </small>
                     </section>
                     <section id="result-moodboard" class="result-section">
                           <!-- Add data attributes -->
                         <h2 data-lang-en="Moodboard Influences" data-lang-es="Influencias del Moodboard">Moodboard Influences</h2>
                          <div class="content">
                              <p id="moodboard-description"></p>
                              <div class="image-placeholder-container" id="moodboard-images"></div>
                         </div>
                          <!-- Add data attributes -->
                          <small data-lang-en="Note: Images are illustrative examples fetched based on AI descriptions. Actual MV visuals require specific direction."
                                 data-lang-es="Nota: Las imágenes son ejemplos ilustrativos obtenidos según las descripciones de la IA. Los visuales reales del MV requieren dirección específica.">
                                Note: Images are illustrative examples...
                          </small>
                     </section>
                     <section id="result-palette" class="result-section">
                           <!-- Add data attributes -->
                         <h2 data-lang-en="Color Palette" data-lang-es="Paleta de Colores">Color Palette</h2>
                         <div class="content">
                            <div class="color-palette-display"></div>
                         </div>
                     </section>
                </div>

            </div>
             <button class="btn btn-secondary btn-back" data-target="home" data-lang-en="Go Back" data-lang-es="Volver">Go Back</button>
        </section>
    </main>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Element References ---
        const navLinks = document.querySelectorAll('.nav-link');
        const pages = document.querySelectorAll('.page');
        const exploreButton = document.getElementById('explore-button'); // Home page button
        const backButtons = document.querySelectorAll('.btn-back');
        const generateConceptButton = document.getElementById('generate-concept-button'); // Renamed
        const initialConceptArea = document.getElementById('initial-concept-area');
        const detailedResultsArea = document.getElementById('detailed-results-area');
        const exploreMoreButton = document.getElementById('explore-more-button');
        const regenerateButton = document.getElementById('regenerate-button');
        const loadingOverlay = document.getElementById('loading-overlay');
        const errorMessageDiv = document.getElementById('error-message');
        const recordAudioButton = document.getElementById('record-audio-button');
        const recordStatus = document.getElementById('record-status');
        const recordingAnimation = document.getElementById('recording-animation');
        const recordStatusText = document.getElementById('record-status-text');
        const lyricsInput = document.getElementById('lyrics-input');
        const keywordsInput = document.getElementById('keywords-input');
        const genreSelect = document.getElementById('genre-select');
        const trackUploadInput = document.getElementById('track-upload');
        const transcriptGroup = document.getElementById('transcript-group');
        const transcriptOutput = document.getElementById('transcript-output');
        const heroImage = document.querySelector('.hero-image'); // For parallax
        const languageSelect = document.getElementById('language-select');
        const allTranslatableElements = document.querySelectorAll('[data-lang-en]'); // Select all elements with base lang attr

        // --- State Variables ---
        let currentInputs = null; // To store form inputs for 'Explore More'
        let currentLang = 'en'; // Default language

        // --- Audio Recording Variables ---
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let recordedAudioBlob = null;
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition;
        let finalTranscript = '';
        let isSpeechRecognitionSupported = !!SpeechRecognition;

        // --- Page Navigation ---
        function showPage(pageId) {
            pages.forEach(page => page.classList.remove('active'));
            const targetPage = document.getElementById(`${pageId}-page`);
            if (targetPage) {
                targetPage.classList.add('active');
            } else {
                console.error("Target page not found:", pageId);
                document.getElementById('home-page').classList.add('active'); // Fallback to home
                pageId = 'home';
            }
            // Update nav links
            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('data-page') === pageId) {
                    link.classList.add('active');
                }
            });
            window.scrollTo(0, 0); // Scroll to top
            if (heroImage) handleScrollParallax(); // Handle parallax
        }

        // --- Loading Overlay Control ---
        function showLoading(messageKey = "Generating creative suggestions...") { // Use key or default text
             if (!loadingOverlay) return;
             const textElement = loadingOverlay.querySelector('p');
             if (textElement) {
                 // Try to get translated message, fallback to English or the key itself
                 const translatedMessage = textElement.dataset['lang' + currentLang] || textElement.dataset['langEn'] || messageKey;
                 textElement.textContent = translatedMessage;
             }
             loadingOverlay.classList.add('show');
             // Disable relevant buttons
             if(generateConceptButton) generateConceptButton.disabled = true;
             if(exploreMoreButton) exploreMoreButton.disabled = true;
             if(regenerateButton) regenerateButton.disabled = true;
        }

        function hideLoading() {
            if (!loadingOverlay) return;
            loadingOverlay.classList.remove('show');
             // Re-enable relevant buttons
             if(generateConceptButton) generateConceptButton.disabled = false;
             if(exploreMoreButton) exploreMoreButton.disabled = false; // Re-enable explore more too
             if(regenerateButton) regenerateButton.disabled = false;
        }


        // --- Microphone Recording Logic (Unchanged) ---
        if (recordAudioButton) {
            recordAudioButton.addEventListener('click', handleRecordButtonClick);
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateRecordStatus('Audio recording not supported.', 'error');
                recordAudioButton.disabled = true;
            } else if (!isSpeechRecognitionSupported) {
                updateRecordStatus('Speech recognition not supported.', 'error');
            }
        }

        async function handleRecordButtonClick() { /* ... Same as before ... */
             if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                updateRecordStatus('Recording not supported by browser.', 'error');
                return;
            }
            if (!isRecording) {
                // Start Recording
                try {
                    recordedAudioBlob = null; trackUploadInput.value = ''; transcriptOutput.value = '';
                    finalTranscript = ''; transcriptGroup.style.display = 'none';
                    updateRecordStatus('Requesting mic access...', '');
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    updateRecordStatus('', 'recording');
                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = event => { if (event.data.size > 0) audioChunks.push(event.data); };
                    mediaRecorder.onstop = () => {
                        if (audioChunks.length > 0) {
                            recordedAudioBlob = new Blob(audioChunks, { type: 'audio/webm;codecs=opus' });
                            if (!recognition || (recognition && recognition.readyState !== 'listening' && recognition.readyState !== 'pending')) {
                                updateRecordStatus(`Recording complete (${(recordedAudioBlob.size / 1024).toFixed(1)} KB).`, 'complete');
                            }
                        } else {
                             if (!recognition || (recognition && recognition.readyState !== 'listening' && recognition.readyState !== 'pending')) {
                                updateRecordStatus('Stopped (no audio captured).', 'error');
                            } recordedAudioBlob = null;
                        }
                        audioChunks = []; stream.getTracks().forEach(track => track.stop()); updateRecordingUI(false);
                    };
                     mediaRecorder.onerror = (event) => { console.error("MediaRecorder error:", event.error); updateRecordStatus(`Recording error: ${event.error.name}`, 'error'); if (recognition && (recognition.readyState === 'listening' || recognition.readyState === 'pending')) { recognition.stop(); } stream.getTracks().forEach(track => track.stop()); updateRecordingUI(false); };

                    if (isSpeechRecognitionSupported) {
                        recognition = new SpeechRecognition(); recognition.continuous = true; recognition.interimResults = true; recognition.lang = languageSelect.value || 'en-US'; // Use selected lang for speech rec
                        recognition.onresult = (event) => {
                            let interimTranscript = ''; finalTranscript = '';
                            for (let i = event.resultIndex; i < event.results.length; ++i) { if (event.results[i].isFinal) { finalTranscript += event.results[i][0].transcript + ' '; } else { interimTranscript += event.results[i][0].transcript; } }
                            const currentFullTranscript = (finalTranscript + interimTranscript).trim(); transcriptOutput.value = currentFullTranscript; if (currentFullTranscript) { transcriptGroup.style.display = 'block'; }
                        };
                        recognition.onerror = (event) => { console.error("Speech Recognition Error:", event.error); let errorMsg = `Transcription error: ${event.error}`; /* ... error messages ... */ if (isRecording) { updateRecordStatus(errorMsg, 'error'); } else { updateRecordStatus('Transcription issue occurred.', 'error'); } };
                        recognition.onend = () => { console.log("Speech recognition ended."); finalTranscript = finalTranscript.trim(); transcriptOutput.value = finalTranscript; if (!isRecording) { /* ... update status based on results ... */ if (finalTranscript && recordedAudioBlob) updateRecordStatus('Recording & Transcription Complete.', 'complete'); else if (finalTranscript && !recordedAudioBlob) updateRecordStatus('Transcription Complete (No Recording Saved).', 'complete'); else if (!finalTranscript && recordedAudioBlob) updateRecordStatus(`Recording complete. No transcript generated.`, 'complete'); else { if (!recordStatus || !recordStatus.classList.contains('error')) updateRecordStatus('Stopped.', ''); } } };
                        recognition.start(); updateRecordStatus('', 'transcribing');
                    } else { updateRecordStatus('', 'recording'); }
                    audioChunks = []; mediaRecorder.start(); updateRecordingUI(true);
                } catch (err) { console.error("Error accessing microphone:", err); /* ... error handling ... */ updateRecordStatus( /* errorMsg */ 'Mic access error.', 'error'); updateRecordingUI(false); }
            } else { // Stop Recording
                if (mediaRecorder && mediaRecorder.state === "recording") { updateRecordStatus('Stopping...', ''); mediaRecorder.stop(); }
                if (recognition && (recognition.readyState === 'listening' || recognition.readyState === 'pending')) { recognition.stop(); }
            }
        }

        function updateRecordingUI(recording) { /* ... Same as before ... */
            if (!recordAudioButton) return;
            isRecording = recording;
            const recordText = recording ? recordAudioButton.dataset.langEnStop || 'Stop Recording' : recordAudioButton.dataset.langEnRecord || 'Record Audio'; // Base text
            const currentRecordText = recordAudioButton.dataset['lang' + currentLang + (recording ? 'Stop' : 'Record')] || recordText;

            if (recording) {
                recordAudioButton.textContent = currentRecordText;
                recordAudioButton.classList.remove('btn-warning'); recordAudioButton.classList.add('btn-danger');
                if(recordingAnimation) recordingAnimation.style.display = 'inline-block';
            } else {
                recordAudioButton.textContent = currentRecordText;
                recordAudioButton.classList.remove('btn-danger'); recordAudioButton.classList.add('btn-warning');
                if(recordingAnimation) recordingAnimation.style.display = 'none';
            }
         }

        function updateRecordStatus(message, statusClass = '') { /* ... Same as before ... */
            if (!recordStatus || !recordStatusText || !recordingAnimation) return;
            recordStatusText.textContent = message; // Add translation here if needed for status messages
            recordStatus.className = 'record-status-base'; if (statusClass) { recordStatus.classList.add(statusClass); }
            if (statusClass === 'recording' || statusClass === 'transcribing') { recordingAnimation.style.display = 'inline-block'; if(statusClass === 'recording') recordStatusText.textContent = ''; } else { recordingAnimation.style.display = 'none'; }
         }

        if(trackUploadInput) { /* ... Same file input clearing logic as before ... */
             trackUploadInput.addEventListener('change', () => {
                 if (trackUploadInput.files.length > 0) {
                     if (isRecording && mediaRecorder && mediaRecorder.state === "recording") { mediaRecorder.stop(); if(recognition && (recognition.readyState === 'listening' || recognition.readyState === 'pending')) recognition.stop(); }
                     updateRecordStatus('', ''); recordedAudioBlob = null; transcriptOutput.value = ''; finalTranscript = ''; transcriptGroup.style.display = 'none'; updateRecordingUI(false); console.log("File selected, cleared recording state.");
                 }
             });
        }

        // --- Gemini API Call Helper ---
        async function callGeminiAPI(promptText, loadingMessageKey = "Generating creative suggestions...") {
            // --- !! SECURITY WARNING REMAINS !! ---
            const GEMINI_API_KEY = "AIzaSyB5c-hp-QeKBpBTz8qwANe4j5Kc4dZ_bWM"; // <-- INSECURE - FOR STUDY ONLY
            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
            // --- !! END WARNING !! ---

            showLoading(loadingMessageKey); // Show loading with appropriate message

            const requestBody = {
                contents: [{ parts: [{ text: promptText }] }],
                generationConfig: { temperature: 0.75, maxOutputTokens: 4096 },
                safetySettings: [ /* Standard safety settings */
                   { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                   { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                ]
            };

            try {
                console.log("Sending API request to Gemini...");
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody),
                 });
                const responseData = await response.json();
                console.log("Raw API Response:", responseData);

                // --- Error Handling ---
                if (!response.ok || responseData?.error || responseData?.promptFeedback?.blockReason) {
                    const errorDetail = responseData?.error?.message || `HTTP Error: ${response.status}`;
                    const safetyFeedback = responseData?.promptFeedback?.blockReason;
                    let errorMessage = `Gemini API Error: ${errorDetail}`;
                    if (safetyFeedback) { errorMessage += ` (Reason: ${safetyFeedback})`; }
                    console.error("Gemini API Error Details:", responseData);
                    throw new Error(errorMessage);
                }

                const candidate = responseData?.candidates?.[0];
                if (!candidate) { throw new Error("No response candidate found from the AI."); }

                if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
                    throw new Error(`Generation failed or was stopped. Reason: ${candidate.finishReason}.`);
                }

                if (candidate?.content?.parts?.[0]?.text) {
                    console.log("Received Gemini response text.");
                    return candidate.content.parts[0].text; // Return the generated text on success
                 } else {
                    console.error("Unexpected response format:", responseData);
                    throw new Error("Received an unexpected or empty response format from the AI.");
                 }

            } catch (error) {
                console.error("Error during Gemini fetch or processing:", error);
                displayError(`Failed to get suggestions. ${error.message}. Please check the console.`);
                return null; // Indicate failure
            } finally {
                hideLoading();
            }
        }

        // --- Generate Initial Concept ---
        async function handleGenerateConcept() {
            const lyrics = lyricsInput.value.trim();
            const keywords = keywordsInput.value.trim();
            const selectedGenre = genreSelect.value;
            const singingTranscript = transcriptOutput.value.trim();

            // Validation
            if (!lyrics) { displayError("Please provide the song lyrics."); return; }
            if (!keywords) { displayError("Please enter some keywords or describe the theme."); return; }
            if (!selectedGenre) { displayError("Please select a music genre from the list."); return; }

            // Store inputs for later
            currentInputs = { lyrics, keywords, selectedGenre, singingTranscript };

            clearResultsAndErrors(); // Clear previous results/errors

            // --- *** PROMPT for ONLY Concept *** ---
            const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
Analyze the following song details:

**Lyrics:**
\`\`\`
${lyrics}
\`\`\`
${singingTranscript ? `\n**Singing Transcript:**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}
**Music Genre:** ${selectedGenre}

Generate **ONLY** the "Concept / Key Visual" section for a music video based on these details.
Structure your response *exactly* like this, starting directly with the header:

## Concept / Key Visual
(Provide a concise, compelling core concept description here. Mention 1-2 key visual motifs or scenes that capture the essence.)
`;
            const generatedText = await callGeminiAPI(prompt, "Generating concept..."); // Use helper

            if (generatedText) {
                parseAndDisplayResults(generatedText); // This will only populate the concept section
                initialConceptArea.style.display = 'block'; // Show concept + buttons
                detailedResultsArea.style.display = 'none'; // Ensure details are hidden
                initialConceptArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                if(exploreMoreButton) exploreMoreButton.disabled = false; // Ensure explore is enabled
            }
            // Errors are handled within callGeminiAPI and displayError
        }

        // --- Explore More Details ---
        async function handleExploreMore() {
            if (!currentInputs) {
                displayError("Cannot explore more without generating a concept first.");
                return;
            }

            if(exploreMoreButton) exploreMoreButton.disabled = true; // Disable immediately

            // --- *** PROMPT for Remaining Details *** ---
             const { lyrics, keywords, selectedGenre, singingTranscript } = currentInputs;
             const prompt = `
You are an AI assistant specialized in generating creative concepts for music videos.
You previously generated a concept based on the following song details:

**Lyrics:**
\`\`\`
${lyrics}
\`\`\`
${singingTranscript ? `\n**Singing Transcript:**\n\`\`\`\n${singingTranscript}\n\`\`\`\n` : ''}
**Keywords/Theme:** ${keywords}
**Music Genre:** ${selectedGenre}

Now, provide the **remaining detailed sections** for the music video based on the *original* song details provided above.
Structure your response *exactly* like this, using markdown headers (##) for each section, and excluding the 'Concept / Key Visual' section:

## Requirements for MV
(List specific, practical requirements: Location(s), Casting, Props, Wardrobe, Cinematography, VFX, Editing Style.)

## Estimated Budget
(Provide Low, Mid, High conceptual breakdowns with rough USD ranges and cost factors.)

## Visual Demo (Key Image Descriptions)
(Describe **exactly 3** distinct key shots/visuals using numbered points (1., 2., 3.).)

## Moodboard Influences
(Describe overall mood. Then list **exactly 5** specific visual elements/influences using bullet points (*).)

## Color Palette
(Suggest 4-6 key colors: Color Name (#XXXXXX), Another Color (#XXXXXX), ...)

Adhere strictly to this format and provide detailed, relevant content for each requested section based on the input song details.
`;

            const generatedText = await callGeminiAPI(prompt, "Fetching details..."); // Use helper

            if (generatedText) {
                parseAndDisplayResults(generatedText); // Populate the detail sections
                detailedResultsArea.style.display = 'block';
                detailedResultsArea.scrollIntoView({ behavior: 'smooth', block: 'start' });
                 // Keep explore button disabled for this concept
            } else {
                 if(exploreMoreButton) exploreMoreButton.disabled = false; // Re-enable if API call failed
            }
        }

        // --- Re-Generate Concept ---
        function handleRegenerateConcept() {
            clearResultsAndErrors(); // Clear everything first
            handleGenerateConcept(); // Start the process over
        }

        // --- Parsing and Displaying Results (Slightly Modified) ---
        function parseAndDisplayResults(text) {
            // No need to clear here, clearing happens before API calls
            console.log("Parsing AI response...");
            const sections = { // Keep all sections defined
                'Concept / Key Visual': 'result-concept',
                'Requirements for MV': 'result-requirements',
                'Estimated Budget': 'result-budget',
                'Visual Demo (Key Image Descriptions)': 'result-visuals',
                'Moodboard Influences': 'result-moodboard',
                'Color Palette': 'result-palette'
            };

            const lines = text.split('\n');
            let currentSectionKey = null;
            let contentBuffer = '';
            let foundAnySection = false;

            lines.forEach(line => {
                let matchedHeader = false;
                for (const title in sections) {
                    const headerRegex = new RegExp(`^\\s*##\\s*${title.trim().replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*$`, 'i');
                    if (headerRegex.test(line.trim())) {
                        if (currentSectionKey && contentBuffer.trim()) {
                            processSectionContent(sections[currentSectionKey], currentSectionKey, contentBuffer.trim());
                            foundAnySection = true;
                        }
                        currentSectionKey = title;
                        contentBuffer = '';
                        matchedHeader = true;
                        break;
                    }
                }
                if (!matchedHeader && currentSectionKey) {
                    contentBuffer += line + '\n';
                }
            });

            if (currentSectionKey && contentBuffer.trim()) {
                processSectionContent(sections[currentSectionKey], currentSectionKey, contentBuffer.trim());
                foundAnySection = true;
            }

            if (!foundAnySection) {
                // Only display error if no sections AT ALL were found in the response
                 if (!document.getElementById('result-concept').querySelector('.content p')?.textContent &&
                     !document.getElementById('result-requirements').querySelector('.content ul')?.children.length) // Check if concept/reqs are also empty
                 {
                    displayError("Could not parse the AI response structure. The response might be empty or not follow the expected format. Raw output logged to console.");
                    console.warn("Raw AI Response Text (Parsing Failed):", text);
                 } else {
                      console.warn("Parsed some sections, but maybe not all expected ones. Raw text:", text);
                 }
            } else {
                 console.log("Parsing complete for received sections.");
                 // Showing areas is handled by the calling functions (handleGenerateConcept/handleExploreMore)
            }
        }

        // --- Process Section Content (Unchanged - relies on finding elements) ---
        function processSectionContent(elementId, sectionTitle, content) { /* ... Same as before ... */
            const sectionElement = document.getElementById(elementId);
            if (!sectionElement) { console.error(`Section element not found: ${elementId}`); return; }
            const contentDiv = sectionElement.querySelector('.content');
            if (!contentDiv) { console.error(`Content div not found in: ${elementId}`); return; }

            // Clear previous content *within this specific section* before processing
            // Exception: For image containers, clear them specifically below if needed
            if (!['result-visuals', 'result-moodboard', 'result-palette', 'result-budget', 'result-requirements'].includes(elementId)) {
                 contentDiv.innerHTML = ''; // Clear general content divs like concept
            }


            try {
                console.log(`Processing Section: ${sectionTitle} into #${elementId}`);

                if (sectionTitle === 'Visual Demo (Key Image Descriptions)') {
                     let imageContainer = contentDiv.querySelector('.image-placeholder-container');
                     if (!imageContainer) { /* ... create container ... */ imageContainer = document.createElement('div'); imageContainer.className = 'image-placeholder-container'; imageContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(220px, 1fr))'; contentDiv.appendChild(imageContainer); }
                     imageContainer.innerHTML = ''; // Clear previous images
                     const descriptions = content.split(/^\s*[1-9][0-9]*\.\s+/gm).filter(Boolean).map(d => d.trim().replace(/\n$/, ''));
                     if (descriptions.length > 0) { descriptions.slice(0, 3).forEach((desc, index) => { if (desc) createImagePlaceholder(imageContainer, desc, `visual-${index}-${Date.now()}`); }); } else { /* ... no descriptions message ... */ imageContainer.innerHTML = `<p style="font-style: italic; color: #6c757d;">No specific visual descriptions found.</p>`; }

                } else if (sectionTitle === 'Moodboard Influences') {
                    let descriptionElement = contentDiv.querySelector('#moodboard-description');
                    if (!descriptionElement) { /* ... create description p ... */ descriptionElement = document.createElement('p'); descriptionElement.id = 'moodboard-description'; contentDiv.appendChild(descriptionElement); }
                    let imageContainer = contentDiv.querySelector('#moodboard-images');
                    if (!imageContainer) { /* ... create image container div ... */ imageContainer = document.createElement('div'); imageContainer.className = 'image-placeholder-container'; imageContainer.id = 'moodboard-images'; imageContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(160px, 1fr))'; contentDiv.appendChild(imageContainer); }
                    imageContainer.innerHTML = ''; descriptionElement.textContent = '';
                    contentDiv.insertBefore(descriptionElement, imageContainer); // Ensure order

                    const firstBulletMatch = content.match(/^\s*[\*\-]\s+/m);
                    let mainDescription = content.trim(); let itemsToProcess = [];
                    if (firstBulletMatch) { mainDescription = content.substring(0, firstBulletMatch.index).trim(); itemsToProcess = content.substring(firstBulletMatch.index).split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(b => b.trim().replace(/\n$/, '')); }
                    descriptionElement.textContent = mainDescription; descriptionElement.style.display = mainDescription ? 'block' : 'none';
                    if (itemsToProcess.length > 0) { itemsToProcess.slice(0, 5).forEach((desc, index) => { if (desc) createImagePlaceholder(imageContainer, desc, `mood-${index}-${Date.now()}`); }); } else if (!mainDescription) { /* ... no description/items message ... */ imageContainer.innerHTML = `<p style="font-style: italic; color: #6c757d;">No moodboard description or items found.</p>`; }

                } else if (sectionTitle === 'Estimated Budget') {
                     let container = contentDiv.querySelector('.budget-columns-container');
                     if(!container){ /* ... create container ... */ container = document.createElement('div'); container.className = 'budget-columns-container'; contentDiv.appendChild(container); }
                     container.innerHTML = ''; // Clear previous columns
                     const budgetLevels = { "Low Budget": null, "Mid Budget": null, "High Budget": null }; const budgetRegex = /\*\s*\*\*(Low|Mid|High) Budget\*\*\s*:?\s*([\s\S]*?)(?=\n\s*\*\s*\*\*|\n*$)/g;
                     let match; while ((match = budgetRegex.exec(content)) !== null) { const level = match[1] + " Budget"; const description = match[2].trim(); if (budgetLevels.hasOwnProperty(level)) budgetLevels[level] = description; }
                     const order = ["Low Budget", "Mid Budget", "High Budget"]; let columnsCreated = 0;
                     order.forEach(level => { if (budgetLevels[level]) { const columnDiv = document.createElement('div'); columnDiv.className = 'budget-column'; const titleH3 = document.createElement('h3'); titleH3.textContent = level; const descP = document.createElement('p'); descP.innerHTML = budgetLevels[level].replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); columnDiv.appendChild(titleH3); columnDiv.appendChild(descP); container.appendChild(columnDiv); columnsCreated++; } });
                     if (columnsCreated === 0) { console.warn("Could not parse budget columns."); contentDiv.innerHTML = `<p style="white-space: pre-wrap;">${content.trim()}</p>`; }

                } else if (sectionTitle === 'Requirements for MV') {
                    let listElement = contentDiv.querySelector('ul');
                    if (!listElement) { /* ... create ul ... */ listElement = document.createElement('ul'); contentDiv.appendChild(listElement); }
                    listElement.innerHTML = ''; // Clear previous items
                    const items = content.trim().split(/^\s*[\*\-]\s+/gm).filter(Boolean).map(item => item.trim().replace(/\n$/, ''));
                    if (items.length > 0) { items.forEach(itemText => { const li = document.createElement('li'); li.innerHTML = itemText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); listElement.appendChild(li); }); } else { console.warn("No requirement items found."); contentDiv.innerHTML = `<p style="white-space: pre-wrap;">${content.trim()}</p>`; }

                } else if (sectionTitle === 'Color Palette') {
                     let paletteContainer = contentDiv.querySelector('.color-palette-display');
                     if (!paletteContainer) { /* ... create container ... */ paletteContainer = document.createElement('div'); paletteContainer.className = 'color-palette-display'; contentDiv.appendChild(paletteContainer); }
                     paletteContainer.innerHTML = ''; // Clear only the palette container
                     createColorSwatches(paletteContainer, content.trim());

                } else { // Concept / Key Visual
                     let pElement = contentDiv.querySelector('p');
                     if(!pElement){ pElement = document.createElement('p'); contentDiv.appendChild(pElement); }
                     pElement.style.whiteSpace = 'pre-wrap';
                     pElement.innerHTML = content.trim().replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                }
                // No need to show sectionElement here, parent visibility is controlled
                // sectionElement.style.display = 'block';
            } catch (error) { console.error(`Error processing section "${sectionTitle}":`, error); contentDiv.innerHTML = `<p style="color: red;">Error displaying this section.</p>`; }
        }

        // --- Unsplash Image Function (Unchanged) ---
        const UNSPLASH_KEYS = [ 'tKEVJi06udyaqpZiOkTKrpLNw6uZfT81dLdfvDcotAM', 'C_PlMOR6NzRK37Om1B0Ewq3byIawwRo6sLOHT4iQLo4' ];
        let unsplashKeyIndex = 0;
        async function createImagePlaceholder(container, description, seedSuffix) { /* ... Same as before ... */
             const figure = document.createElement('figure'); figure.className = 'image-placeholder'; const img = document.createElement('img'); /* ... img styles ... */ img.style.backgroundColor = '#e9ecef'; img.alt = `Loading: ${description}`; img.src = ''; img.loading = 'lazy'; let placeholderHeight = container && container.closest('#result-moodboard') ? 140 : 180; img.style.height = `${placeholderHeight}px`; img.style.width = '100%'; img.style.objectFit = 'cover'; const figcaption = document.createElement('figcaption'); figcaption.innerHTML = description.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); figure.appendChild(img); figure.appendChild(figcaption); container.appendChild(figure);
             const currentKeyIndex = unsplashKeyIndex; const currentUnsplashKey = UNSPLASH_KEYS[currentKeyIndex]; unsplashKeyIndex = (unsplashKeyIndex + 1) % UNSPLASH_KEYS.length;
             if (!currentUnsplashKey || currentUnsplashKey.startsWith('YOUR_') || currentUnsplashKey.length < 20) { console.warn(`Invalid Unsplash Key (index ${currentKeyIndex}).`); setFallbackImage(img, figcaption, description, seedSuffix, 'no-key', placeholderHeight); return; }
             try { let query = description.replace(/<[^>]*>/g, '').replace(/[^a-zA-Z0-9\s,.]/g, '').trim(); query = query.length > 60 ? query.substring(0, 60).split(' ').slice(0, -1).join(' ') : query; if (!query) { console.warn("Empty image query."); setFallbackImage(img, figcaption, description, seedSuffix, 'empty-query', placeholderHeight); return; }
                const searchUrl = `https://api.unsplash.com/search/photos?query=${encodeURIComponent(query)}&per_page=1&orientation=landscape&client_id=${currentUnsplashKey}`; console.log(`Fetching Unsplash: Query='${query}'`);
                const response = await fetch(searchUrl); const responseData = await response.json(); console.log(`Unsplash Status: ${response.status}`);
                if (!response.ok) { let errorMsg = `Unsplash API error: ${response.status}`; if (responseData && responseData.errors) errorMsg += ` - ${responseData.errors[0]}`; console.error(errorMsg); setFallbackImage(img, figcaption, description, seedSuffix, 'api-error', placeholderHeight); return; }
                if (responseData.results && responseData.results.length > 0) { const imageResult = responseData.results[0]; img.src = imageResult.urls.small; img.alt = imageResult.alt_description || description; const attributionLink = document.createElement('a'); attributionLink.href = imageResult.links.html + '?utm_source=mv_assistant&utm_medium=referral'; attributionLink.target = '_blank'; attributionLink.rel = 'noopener noreferrer'; attributionLink.innerHTML = `Photo by <span style="text-decoration: underline;">${imageResult.user.name}</span> on <span style="text-decoration: underline;">Unsplash</span>`; figcaption.appendChild(attributionLink); } else { console.warn(`No Unsplash image found for: "${query}".`); setFallbackImage(img, figcaption, description, seedSuffix, 'not-found', placeholderHeight); }
             } catch (error) { console.error(`Failed Unsplash fetch for "${description}"`, error); setFallbackImage(img, figcaption, description, seedSuffix, 'fetch-error', placeholderHeight); }
        }
        function setFallbackImage(imgElement, figcaptionElement, description, seedSuffix, reason, height) { /* ... Same as before ... */ const seed = encodeURIComponent(description.substring(0, 25) + seedSuffix + '-' + reason); const picSumHeight = Math.round(height * 1.5); imgElement.src = `https://picsum.photos/seed/${seed}/400/${picSumHeight}`; imgElement.alt = `Placeholder: ${description}`; const fallbackNotice = document.createElement('span'); fallbackNotice.className = 'fallback-notice'; fallbackNotice.textContent = `(Placeholder: ${reason})`; if (figcaptionElement.querySelector('a')) { figcaptionElement.insertBefore(fallbackNotice, figcaptionElement.querySelector('a')); } else { figcaptionElement.appendChild(fallbackNotice); } }

        // --- Color Swatch Creation (Unchanged) ---
        function createColorSwatches(container, text) { /* ... Same as before ... */
             if (!container) { console.error("createColorSwatches null container."); return; } container.innerHTML = ''; const colorRegex = /([\w\s\-\/]+?)\s*\(\s*(#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3})\s*\)/g; let match; let foundColors = false; console.log("Parsing colors from:\n", text);
             while ((match = colorRegex.exec(text)) !== null) { foundColors = true; const colorName = match[1].trim().replace(/[\s,-]+$/, ''); let hexCode = match[2].trim().toUpperCase(); if (hexCode.length === 4) hexCode = '#' + hexCode[1] + hexCode[1] + hexCode[2] + hexCode[2] + hexCode[3] + hexCode[3]; if (hexCode.length !== 7) { console.warn(`Skipping invalid hex: ${match[2]}`); continue; } console.log(`   Found color: ${colorName} (${hexCode})`); const swatch = document.createElement('div'); swatch.className = 'color-swatch'; try { swatch.style.backgroundColor = hexCode; swatch.style.color = isColorDarkGuess(hexCode) ? '#FFFFFF' : '#333333'; } catch (e) { swatch.style.backgroundColor = '#CCCCCC'; swatch.style.color = '#000000'; } const nameSpan = document.createElement('span'); nameSpan.textContent = colorName; const hexSpan = document.createElement('span'); hexSpan.className = 'hex-code'; hexSpan.textContent = hexCode; swatch.appendChild(nameSpan); swatch.appendChild(hexSpan); container.appendChild(swatch); }
             if (!foundColors) { console.warn("Could not parse colors."); container.innerHTML = `<p style="font-style: italic; color: #6c757d;">Could not parse colors in 'Name (#XXXXXX)' format.</p>`; } else { console.log(`Created ${container.children.length} swatches.`); }
        }

        // --- Color Lightness Guess (Unchanged) ---
        function isColorDarkGuess(hexColor) { /* ... Same as before ... */ try { if (!hexColor || typeof hexColor !== 'string' || !hexColor.startsWith('#')) return false; let hex = hexColor.substring(1); if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]; if (hex.length !== 6) return false; const r = parseInt(hex.substring(0, 2), 16); const g = parseInt(hex.substring(2, 4), 16); const b = parseInt(hex.substring(4, 6), 16); const luminance = (0.2126 * r + 0.7152 * g + 0.0722 * b) / 255; return luminance < 0.5; } catch (e) { console.error("Error parsing hex:", hexColor, e); return false; } }

        // --- Utility Functions ---
        function clearResultsAndErrors() {
            // Hide main containers
            initialConceptArea.style.display = 'none';
            detailedResultsArea.style.display = 'none';
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';

            // Clear content within sections (important for re-generate)
            const allResultSections = document.querySelectorAll('#initial-concept-area .result-section, #detailed-results-area .result-section');
            allResultSections.forEach(section => {
                const contentDiv = section.querySelector('.content');
                if (contentDiv) contentDiv.innerHTML = ''; // Clear broadly, specific containers will repopulate

                // Ensure specific containers are definitely empty
                 const pContainers = section.querySelectorAll('p');
                 pContainers.forEach(p => p.innerHTML = '');
                 const ulContainers = section.querySelectorAll('ul');
                 ulContainers.forEach(ul => ul.innerHTML = '');
                 const divContainers = section.querySelectorAll('.image-placeholder-container, .budget-columns-container, .color-palette-display');
                 divContainers.forEach(div => div.innerHTML = '');
            });

             // Re-enable explore button if it exists
             if(exploreMoreButton) exploreMoreButton.disabled = false;

            console.log("Cleared previous results and errors.");
        }

        function displayError(messageKey) { // Accept key or text
             // Attempt translation
             const errorElementForLang = document.getElementById('error-message') || {}; // Use dummy if not found
             const translatedMessage = errorElementForLang.dataset ? (errorElementForLang.dataset['lang' + currentLang] || errorElementForLang.dataset['langEn'] || messageKey) : messageKey;

             errorMessageDiv.textContent = translatedMessage;
             errorMessageDiv.style.display = 'block';
             initialConceptArea.style.display = 'none'; // Hide results on error
             detailedResultsArea.style.display = 'none';
             hideLoading();
             console.error("Displayed user error message:", translatedMessage);
        }

        // --- Parallax Effect (Unchanged) ---
        let isParallaxEnabled = true; let rafId = null;
        function handleScrollParallax() { /* ... Same as before ... */ if (rafId) cancelAnimationFrame(rafId); if (!heroImage || !isParallaxEnabled || !document.getElementById('home-page').classList.contains('active')) { if (heroImage && heroImage.style.transform !== 'scale(1.1) translateY(0px)') { rafId = requestAnimationFrame(() => { heroImage.style.transform = 'scale(1.1) translateY(0px)'; }); } return; } const scrollY = window.scrollY; const parallaxFactor = 0.3; const translateY = scrollY * parallaxFactor; rafId = requestAnimationFrame(() => { if (heroImage && isParallaxEnabled && document.getElementById('home-page').classList.contains('active')) { heroImage.style.transform = `scale(1.1) translateY(${translateY}px)`; } }); }
        function checkParallaxStatus() { /* ... Same as before ... */ if (window.innerWidth < 768) { if (isParallaxEnabled && heroImage) { if (rafId) cancelAnimationFrame(rafId); heroImage.style.transform = 'scale(1.1) translateY(0px)'; } isParallaxEnabled = false; } else { isParallaxEnabled = true; handleScrollParallax(); } console.log(`Parallax enabled: ${isParallaxEnabled}`); }

        // --- Language Switching Functions ---
        function updateLanguage(langCode) {
            currentLang = langCode;
            console.log(`Switching language to: ${langCode}`);

            allTranslatableElements.forEach(el => {
                const translationKey = 'lang' + langCode.charAt(0).toUpperCase() + langCode.slice(1).replace('-', ''); // Format key e.g., langEs, langZhCN
                const fallbackKey = 'langEn';
                const translation = el.dataset[translationKey] || el.dataset[fallbackKey]; // Get specific lang or fallback to English

                if (translation) {
                    // Check for placeholder attributes (need specific handling)
                    const placeholderKey = 'lang' + langCode.charAt(0).toUpperCase() + langCode.slice(1).replace('-', '') + 'Placeholder';
                    const fallbackPlaceholderKey = 'langEnPlaceholder';
                    const placeholderTranslation = el.dataset[placeholderKey] || el.dataset[fallbackPlaceholderKey];

                    if (placeholderTranslation && (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT')) {
                        el.placeholder = placeholderTranslation;
                    } else if (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') {
                        // If specific placeholder lang not found, try using general translation as placeholder
                        el.placeholder = translation;
                    } else if (el.tagName === 'TITLE') {
                         document.title = translation; // Update page title
                    }
                    else {
                        el.textContent = translation; // Update text content for other elements
                    }
                } else {
                     // Optional: Log if an element has data-lang-en but not the target lang
                     // console.warn(`No translation found for key ${translationKey} on element:`, el);
                }
            });

             // Update Record button text dynamically if needed
             updateRecordingUI(isRecording);
             // Update loading overlay text if visible
             if (loadingOverlay.classList.contains('show')) {
                 const loadingP = loadingOverlay.querySelector('p');
                 if (loadingP) {
                     loadingP.textContent = loadingP.dataset['lang' + langCode] || loadingP.dataset['langEn'] || "Loading...";
                 }
             }
             // Update genre select default option
             const genreDefaultOption = genreSelect.querySelector('option[disabled]');
             if (genreDefaultOption) {
                  genreDefaultOption.textContent = genreDefaultOption.dataset['lang' + langCode] || genreDefaultOption.dataset['langEn'] || "-- Select --";
             }

             // Update speech recognition language if supported and recorder instance exists
             if (recognition) {
                 recognition.lang = langCode === 'zh-CN' ? 'zh-CN' : langCode.split('-')[0] + '-' + langCode.split('-')[0].toUpperCase(); // Attempt standard BCP 47 format
                 console.log("Updated speech recognition language to:", recognition.lang);
             }
        }


        function saveLanguagePreference(langCode) {
            try {
                localStorage.setItem('mvAssistantLang', langCode);
            } catch (e) {
                console.warn("Could not save language preference to localStorage:", e);
            }
        }

        function loadLanguagePreference() {
            try {
                const savedLang = localStorage.getItem('mvAssistantLang');
                if (savedLang && languageSelect.querySelector(`option[value="${savedLang}"]`)) {
                    languageSelect.value = savedLang;
                    return savedLang;
                }
            } catch (e) {
                console.warn("Could not load language preference from localStorage:", e);
            }
            return languageSelect.value; // Default to selected value in HTML ('en')
        }

        // --- Event Listeners Setup --- //
        // Page Navigation
        navLinks.forEach(link => { link.addEventListener('click', (e) => { e.preventDefault(); showPage(link.getAttribute('data-page')); }); });
        if (exploreButton) { exploreButton.addEventListener('click', () => showPage('feature')); }
        backButtons.forEach(button => { button.addEventListener('click', (e) => { e.preventDefault(); showPage('home'); }); });

        // Feature Page Buttons
        if (generateConceptButton) { generateConceptButton.addEventListener('click', handleGenerateConcept); } else { console.error("FATAL: Generate Concept button not found!"); }
        if (exploreMoreButton) { exploreMoreButton.addEventListener('click', handleExploreMore); } else { console.error("FATAL: Explore More button not found!"); }
        if (regenerateButton) { regenerateButton.addEventListener('click', handleRegenerateConcept); } else { console.error("FATAL: Re-Generate button not found!"); }

        // Language Selector
        if (languageSelect) {
            languageSelect.addEventListener('change', (e) => {
                const newLang = e.target.value;
                updateLanguage(newLang);
                saveLanguagePreference(newLang);
            });
        }

        // Parallax Listeners
        checkParallaxStatus();
        window.addEventListener('scroll', handleScrollParallax, { passive: true });
        window.addEventListener('resize', checkParallaxStatus);


        // --- Initial Setup ---
        const initialLang = loadLanguagePreference();
        updateLanguage(initialLang); // Apply loaded/default language on start
        showPage('home'); // Show the initial page
        console.log("MV Assistant Initialized.");

    }); // End DOMContentLoaded
</script>

</body>
</html>
